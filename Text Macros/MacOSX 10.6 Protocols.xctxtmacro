(
	//
	// Protocol implementations for Objective-C & Objective-C++
	//
	// File generated by protocols2textmacros.sh & extract_protocols.sed (v1.5.1)
	//   (Tools by O.Halligon, Sept 2009)
	//
	{
		Identifier = objc.protocols10_6;
		Name = "MacOSX 10.6 Protocols implementation";
		IsMenu = YES;
		ComputerLanguages = ( "c.objc", "c.objcpp" );
		IncludeContexts = ( "xcode.lang.objc.implementation" );
		ExcludeContexts = ( "xcode.lang.objc.block", "xcode.lang.string", "xcode.lang.character", "xcode.lang.comment", "xcode.lang.c.preprocessor" );
		// OnlyAtBOL = YES; /* actually useless as the inheritence mechanism seems not to be implemented for this key */
    },

	// 
	// Protocol ABImageClient
	// 
	{
		Identifier = objc.protocols10_6.ABImageClient;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "ABImageClient implementation (MacOSX 10.6)";
		CompletionPrefix = "ABImageClient";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: ABImageClient implementation
//

- (void)consumeImageData:(NSData *)data forTag:(NSInteger)tag
{
	// required method
	<#statements_0#>
}
";
	},

	// 
	// Protocol NSAlertDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSAlertDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSAlertDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSAlertDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSAlertDelegate implementation
//

/* the delegate should implement this if custom help behavior is required.
*/
/*
- (BOOL)alertShowHelp:(NSAlert *)alert
{
	// optional method
	<#statements_1#>
}
*/
";
	},

	// 
	// Protocol NSAnimationDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSAnimationDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSAnimationDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSAnimationDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSAnimationDelegate implementation
//

/*
- (BOOL)animationShouldStart:(NSAnimation*)animation
{
	// optional method
	<#statements_2#>
}
*/
/*
- (void)animationDidStop:(NSAnimation*)animation
{
	// optional method
	<#statements_3#>
}
*/
/*
- (void)animationDidEnd:(NSAnimation*)animation
{
	// optional method
	<#statements_4#>
}
*/
/*
- (float)animation:(NSAnimation*)animation valueForProgress:(NSAnimationProgress)progress
{
	// optional method
	<#statements_5#>
}
*/
/*
- (void)animation:(NSAnimation*)animation didReachProgressMark:(NSAnimationProgress)progress
{
	// optional method
	<#statements_6#>
}
*/
";
	},

	// 
	// Protocol NSApplicationDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSApplicationDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSApplicationDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSApplicationDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSApplicationDelegate implementation
//

/* 
    Allowable return values are:
        NSTerminateNow - it is ok to proceed with termination
        NSTerminateCancel - the application should not be terminated
        NSTerminateLater - it may be ok to proceed with termination later.  The application must call -replyToApplicationShouldTerminate: with YES or NO once the answer is known
            this return value is for delegates who need to provide document modal alerts (sheets) in order to decide whether to quit.
*/
/*
- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
{
	// optional method
	<#statements_7#>
}
*/
/*
- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename
{
	// optional method
	<#statements_8#>
}
*/
/*
- (void)application:(NSApplication *)sender openFiles:(NSArray *)filenames
{
	// optional method
	<#statements_9#>
}
*/
/*
- (BOOL)application:(NSApplication *)sender openTempFile:(NSString *)filename
{
	// optional method
	<#statements_10#>
}
*/
/*
- (BOOL)applicationShouldOpenUntitledFile:(NSApplication *)sender
{
	// optional method
	<#statements_11#>
}
*/
/*
- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender
{
	// optional method
	<#statements_12#>
}
*/
/*
- (BOOL)application:(id)sender openFileWithoutUI:(NSString *)filename
{
	// optional method
	<#statements_13#>
}
*/
/*
- (BOOL)application:(NSApplication *)sender printFile:(NSString *)filename
{
	// optional method
	<#statements_14#>
}
*/
/*
- (NSApplicationPrintReply)application:(NSApplication *)application printFiles:(NSArray *)fileNames withSettings:(NSDictionary *)printSettings showPrintPanels:(BOOL)showPrintPanels
{
	// optional method
	<#statements_15#>
}
*/
/*
- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)sender
{
	// optional method
	<#statements_16#>
}
*/
/*
- (BOOL)applicationShouldHandleReopen:(NSApplication *)sender hasVisibleWindows:(BOOL)flag
{
	// optional method
	<#statements_17#>
}
*/
/*
- (NSMenu *)applicationDockMenu:(NSApplication *)sender
{
	// optional method
	<#statements_18#>
}
*/
/*
- (NSError *)application:(NSApplication *)application willPresentError:(NSError *)error
{
	// optional method
	<#statements_19#>
}
*/
/* Notifications:
 */
/*
- (void)applicationWillFinishLaunching:(NSNotification *)notification
{
	// optional method
	<#statements_20#>
}
*/
/*
- (void)applicationDidFinishLaunching:(NSNotification *)notification
{
	// optional method
	<#statements_21#>
}
*/
/*
- (void)applicationWillHide:(NSNotification *)notification
{
	// optional method
	<#statements_22#>
}
*/
/*
- (void)applicationDidHide:(NSNotification *)notification
{
	// optional method
	<#statements_23#>
}
*/
/*
- (void)applicationWillUnhide:(NSNotification *)notification
{
	// optional method
	<#statements_24#>
}
*/
/*
- (void)applicationDidUnhide:(NSNotification *)notification
{
	// optional method
	<#statements_25#>
}
*/
/*
- (void)applicationWillBecomeActive:(NSNotification *)notification
{
	// optional method
	<#statements_26#>
}
*/
/*
- (void)applicationDidBecomeActive:(NSNotification *)notification
{
	// optional method
	<#statements_27#>
}
*/
/*
- (void)applicationWillResignActive:(NSNotification *)notification
{
	// optional method
	<#statements_28#>
}
*/
/*
- (void)applicationDidResignActive:(NSNotification *)notification
{
	// optional method
	<#statements_29#>
}
*/
/*
- (void)applicationWillUpdate:(NSNotification *)notification
{
	// optional method
	<#statements_30#>
}
*/
/*
- (void)applicationDidUpdate:(NSNotification *)notification
{
	// optional method
	<#statements_31#>
}
*/
/*
- (void)applicationWillTerminate:(NSNotification *)notification
{
	// optional method
	<#statements_32#>
}
*/
/*
- (void)applicationDidChangeScreenParameters:(NSNotification *)notification
{
	// optional method
	<#statements_33#>
}
*/
";
	},

	// 
	// Protocol NSBrowserDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSBrowserDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSBrowserDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSBrowserDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSBrowserDelegate implementation
//

/* As of Mac OS X 10.6, browser has two different mechanisms for populating columns. You may implement either the matrix or item delegate methods listed below. Many newer features of the browser are only available if you implement the item delegate methods. */
/* Implement one of the following two methods to populate the browser's columns with instances of NSMatrix.
 */
/* Called by the browser to determine the number of rows in the given column. The delegate will be called with -browser:willDisplayCell:atRow:column: before displaying each cell, giving it a chance to fill in the NSBrowserCell properties.
 */
/*
- (NSInteger)browser:(NSBrowser *)sender numberOfRowsInColumn:(NSInteger)column
{
	// optional method
	<#statements_34#>
}
*/
/* Called by the browser to fill in the matrix with populated NSBrowserCells.
 */
/*
- (void)browser:(NSBrowser *)sender createRowsForColumn:(NSInteger)column inMatrix:(NSMatrix *)matrix
{
	// optional method
	<#statements_35#>
}
*/
/* Alternatively, implement all of the following methods, patterened after NSOutlineView's data source methods. Note that browsers with delegates implementing these methods do not use NSMatrix to populate columns; the implementation is private. The item parameter passed to each of these methods will be nil if the browser is querying about the root of the tree, unless -rootItemForBrowser: is implemented.
*/
/* Return the number of children of the given item. */
/*
- (NSInteger)browser:(NSBrowser *)browser numberOfChildrenOfItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_36#>
}
*/
/* Return the indexth child of item. You may expect that index is never equal to or greater to the number of children of item as reported by -browser:numberOfChildrenOfItem:.
 */
/*
- (id)browser:(NSBrowser *)browser child:(NSInteger)index ofItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_37#>
}
*/
/* Return whether item should be shown as a leaf item; that is, an item that can not be expanded into another column. Returning NO does not prevent you from returning 0 from -browser:numberOfChildrenOfItem:.
 */
/*
- (BOOL)browser:(NSBrowser *)browser isLeafItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_38#>
}
*/
/* Return the object value passed to the cell displaying item.
 */
/*
- (id)browser:(NSBrowser *)browser objectValueForItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_39#>
}
*/
/* Optional - Variable Row Heights
    Implement this method to support varying row heights per column.  The height returned by this method should not include intercell spacing and must be greater than zero.  NSBrowser may cache the values this method returns.  So if you would like to change a row's height make sure to invalidate the row height by calling -noteHeightOfRowsWithIndexesChanged:inColumn:.
*/
/*
- (CGFloat)browser:(NSBrowser *)browser heightOfRow:(NSInteger)row inColumn:(NSInteger)columnIndex AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_40#>
}
*/
/* Optional - Alternate root item. 
 By default, NSBrowser uses 'nil' to identify the root item. It can optionally use a different root item provided by this delegate method. To reload the rootItem that was previously set, call -loadColumnZero, and NSBrowser will call -rootItemForBrowser: again.
 */
/*
- (id)rootItemForBrowser:(NSBrowser *)browser AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_41#>
}
*/
/* Optional - editing support.
 Implement this method to support editing of browser items. The browser will pass back the object value from the cell displaying item.
 */
/*
- (void)browser:(NSBrowser *)browser setObjectValue:(id)object forItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_42#>
}
*/
/* Optional - editing support.
 Implement this method to control whether the browser may start an editing session for item.
 */
/*
- (BOOL)browser:(NSBrowser *)browser shouldEditItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_43#>
}
*/
/* Optional - display support.
 Called by the browser before displaying a cell at the given location.
 */
/*
- (void)browser:(NSBrowser *)sender willDisplayCell:(id)cell atRow:(NSInteger)row column:(NSInteger)column
{
	// optional method
	<#statements_44#>
}
*/
/*
- (NSString *)browser:(NSBrowser *)sender titleOfColumn:(NSInteger)column
{
	// optional method
	<#statements_45#>
}
*/
/* Called by the browser when selecting cells by title, either from -setPath:, or when recomputing the selection after -reloadColumn:. Return NO if a matching cell could not be found.
 */
/*
- (BOOL)browser:(NSBrowser *)sender selectCellWithString:(NSString *)title inColumn:(NSInteger)column
{
	// optional method
	<#statements_46#>
}
*/
/* Called by the browser when selecting a cell using -selectRow:inColumn:. Return NO if a matching cell could not be found.
 */
/*
- (BOOL)browser:(NSBrowser *)sender selectRow:(NSInteger)row inColumn:(NSInteger)column
{
	// optional method
	<#statements_47#>
}
*/
/* Called by the browser from -validateVisibleColumns to determine whether the currently-displayed columns are valid. Returning NO will prompt the browser to call -reloadColumn:.
 */
/*
- (BOOL)browser:(NSBrowser *)sender isColumnValid:(NSInteger)column
{
	// optional method
	<#statements_48#>
}
*/
/*
- (void)browserWillScroll:(NSBrowser *)sender
{
	// optional method
	<#statements_49#>
}
*/
/*
- (void)browserDidScroll:(NSBrowser *)sender
{
	// optional method
	<#statements_50#>
}
*/
/*
 * Delegate methods used by resizable column browsers.
 */
/* Optional for browsers with resize type NSBrowserNoColumnResizing, and NSBrowserUserColumnResizing.
 This method is used for both constraining column resize, and determining a columns initial size.  If 'forUserResize' is NO, this method should return the initial width for a newly added column.  If 'forUserResize' is YES, this method can be used to constrain resizing on a per-column basis.  (Currently per-column constraining is not implemented, so forUserResize will always be NO).
 */
/*
- (CGFloat)browser:(NSBrowser *)browser shouldSizeColumn:(NSInteger)columnIndex forUserResize:(BOOL)forUserResize toWidth:(CGFloat)suggestedWidth AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
{
	// optional method
	<#statements_51#>
}
*/
/* Optional for browsers with resize type NSBrowserUserColumnResizing only.
 This method returns the \"ideal\" width for a column.  This method is used when performing a \"right-size-each\" or \"right-size-one\" operation.  If columnIndex is -1, the result is used for a \"right-size-all-simultaneous\" operation.  In this case, you should return a best uniform right size for all column (every column will be set to this size).  You can opt out on a per column basis by returning -1 for that column. It is assumed that the implementation may be expensive, so it will be called only when necessary.  (See documentation for definitions of right-size one/each/all). 
 */
/*
- (CGFloat)browser:(NSBrowser *)browser sizeToFitWidthOfColumn:(NSInteger)columnIndex AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
{
	// optional method
	<#statements_52#>
}
*/
/* Optional and used for browsers with resize type NSBrowserUserColumnResizing only.
 This method is intended to be used by clients wishing to implement their own column width persistence.  It is called when the width of any browser columns has changed.  User column resizing will cause a single notification to be posted when the user is finished resizing.  (See NSBrowserColumnConfigurationDidChangeNotification for more information.)  
 */
/*
- (void)browserColumnConfigurationDidChange:(NSNotification *)notification AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
{
	// optional method
	<#statements_53#>
}
*/
/* Optional - Expansion ToolTip support.
    Implement this method and return NO to prevent an expansion tooltip from appearing for a particular cell at 'row' in 'column'. See NSCell.h for more information on expansion tool tips. 
 */
/*
- (BOOL)browser:(NSBrowser *)browser shouldShowCellExpansionForRow:(NSInteger)row column:(NSInteger)column AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_54#>
}
*/
/* This method is called after it has been determined that a drag should begin, but before the drag has been started.  To refuse the drag, return NO. To start a drag, declared the pasteboard types that you support with [pasteboard declareTypes:owner:], place your data on the pasteboard, and return YES from the method. The drag image and other drag related information will be set up and provided by the view once this call returns with YES. You need to implement this method for your browser to be a drag source. 
 */
/*
- (BOOL)browser:(NSBrowser *)browser writeRowsWithIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column toPasteboard:(NSPasteboard *)pasteboard AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_55#>
}
*/
/* The delegate can support file promise drags by adding NSFilesPromisePboardType to the pasteboard in browser:writeRowsWithIndexes:inColumn:toPasteboard:. NSBrowser implements -namesOfPromisedFilesDroppedAtDestination: to return the results of this data source method.  This method should returns an array of filenames for the created files (filenames only, not full paths).  The URL represents the drop location.  For more information on file promise dragging, see documentation on the NSDraggingSource protocol and -namesOfPromisedFilesDroppedAtDestination:. You do not need to implement this method for your browser to be a drag source.
 */
/*
- (NSArray *)browser:(NSBrowser *)browser namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropDestination forDraggedRowsWithIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_56#>
}
*/
/* The delegate can control if some particular rows can be dragged or not for a particular event. You do not need to implement this method for your browser to be a drag source. 
 */
/*
- (BOOL)browser:(NSBrowser *)browser canDragRowsWithIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column withEvent:(NSEvent *)event AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_57#>
}
*/
/* Allows the delegate to compute a dragging image for the particular cells being dragged. 'rowIndexes' are the indexes of the cells being dragged in the matrix in 'column'. 'event' is a reference to the mouse down event that began the drag. 'dragImageOffset' is an in/out parameter. This method will be called with dragImageOffset set to NSZeroPoint, but it can be modified to re-position the returned image.  A dragImageOffset of NSZeroPoint will cause the image to be centered under the mouse. You can safely call [browser dragImageForRowsWithIndexes:inColumn:withEvent:offset:] from inside this method. You do not need to implement this method for your browser to be a drag source. You can safely call the corresponding NSBrowser method.
 */
/*
- (NSImage *)browser:(NSBrowser *)browser draggingImageForRowsWithIndexes:(NSIndexSet *)rowIndexes inColumn:(NSInteger)column withEvent:(NSEvent *)event offset:(NSPointPointer)dragImageOffset AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_58#>
}
*/
/* This method is used by the browser to determine a valid drop target. Based on the mouse position, the browser will suggest a proposed row, column and dropOperation. These values are in/out parameters and can be changed by the delegate to retarget the drop operation. The dropOperation suggested will be NSBrowserDropOn if the drag location is closer to the middle of a row. If it is closer to being between two rows, it will be NSBrowserDropAbove, indicating a drop above 'row' and below 'row - 1'. This method must return a value that indicates which dragging operation the data source will perform. It must return something other than NSDragOperationNone to accept the drop.

    To retarget a drop and specify a drop on row 2 (with the first visual row being row 0), one would set *row=2, and set *dropOperation=NSBrowserDropOn. To specify a drop below the last row, one would specify *row=[browser numberOfRows], and *dropOperation=NSBrowserDropAbove. To specify a drop on the entire column, you will specify *row=-1, and *dropOperation=NSBrowserDropOn. To specify a drop between rows 2 and 3, one would set *row=3 and *dropOperation=NSBrowserDropAbove.

    Note: to receive drag messages, you must first call [NSBrowser registerForDraggedTypes:] for the drag types you want to support (typically this is done in awakeFromNib). You must implement this method for your browser to be a drag destination. 
*/
/*
- (NSDragOperation)browser:(NSBrowser *)browser validateDrop:(id <NSDraggingInfo>)info proposedRow:(NSInteger *)row column:(NSInteger *)column  dropOperation:(NSBrowserDropOperation *)dropOperation AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_59#>
}
*/
/* This method is called when the mouse is released over a browser that previously decided to allow a drop via the above validateDrop method.  The delegate should incorporate the data from the dragging pasteboard at this time. You must implement this method for your browser to be a drag destination.
*/
/*
- (BOOL)browser:(NSBrowser *)browser acceptDrop:(id <NSDraggingInfo>)info atRow:(NSInteger)row column:(NSInteger)column dropOperation:(NSBrowserDropOperation)dropOperation AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_60#>
}
*/
/* Optional - Type select support
    Implement this method if you want to control the string that is used for type selection. You may want to change what is searched for based on what is displayed, or simply return an empty string for that row and/or column to not be searched. You can also return 'nil' if the cell does not contain any text. By default, all cells with text in them are searched. The default value when this delegate method is not implemented is the stringValue for the cell at that location.
 */
/*
- (NSString *)browser:(NSBrowser *)browser typeSelectStringForRow:(NSInteger)row inColumn:(NSInteger)column AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_61#>
}
*/
/* Optional - Type select support
    Implement this method if you would like to prevent a type select from happening based on the current event and current search string. Generally, this will be called from keyDown: and the event will be a key event. The search string will be nil if no type select has began. 
 */
/*
- (BOOL)browser:(NSBrowser *)browser shouldTypeSelectForEvent:(NSEvent *)event withCurrentSearchString:(NSString *)searchString AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_62#>
}
*/
/* Optional - Type select support
    Implement this method if you want to control how type selection works. Return the first row that matches searchString from within the range of startRow to endRow. It is possible for endRow to be less than startRow if the search will wrap. Return -1 when there is no match. Include startRow as a possible match, but do not include endRow. It is not necessary to implement this method in order to support type select.
 */
/*
- (NSInteger)browser:(NSBrowser *)browser nextTypeSelectMatchFromRow:(NSInteger)startRow toRow:(NSInteger)endRow inColumn:(NSInteger)column forString:(NSString *)searchString AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_63#>
}
*/
/* Optional - Preview column support
    Implement this method to provide a preview column for leaf items. Return nil to suppress the preview column. The controller's representedObject will be set to the browser's selected leaf item. This method is only called if the delegate implements the item data source methods.
 */
/*
- (NSViewController *)browser:(NSBrowser *)browser previewViewControllerForLeafItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_64#>
}
*/
/* Optional - Column header support
    Implement this method to provide a header view for columns. Return nil to omit the header view. The controller's representedObject will be set to the column's item. This method is only called if the delegate implements the item data source methods.
 */
/*
- (NSViewController *)browser:(NSBrowser *)browser headerViewControllerForItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_65#>
}
*/
/* Optional - Notification when the lastColumn changes.
 */
/*
- (void)browser:(NSBrowser *)browser didChangeLastColumn:(NSInteger)oldLastColumn toColumn:(NSInteger)column
{
	// optional method
	<#statements_66#>
}
*/
/* Optional - Return a set of new indexes to select when the user changes the selection with the keyboard or mouse. This method may be called multiple times with one new index added to the existing selection to find out if a particular index can be selected when the user is extending the selection with the keyboard or mouse. Note that 'proposedSelectionIndexes' will contain the entire newly suggested selection, and you can return the exsiting selection to avoid changing the selection. This method only works for item-based NSBrowsers.
 */
/*
- (NSIndexSet *)browser:(NSBrowser *)browser selectionIndexesForProposedSelection:(NSIndexSet *)proposedSelectionIndexes inColumn:(NSInteger)column AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_67#>
}
*/
";
	},

	// 
	// Protocol NSCollectionViewDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSCollectionViewDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSCollectionViewDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSCollectionViewDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSCollectionViewDelegate implementation
//

/* Drag and drop support */
/* The return value indicates whether the collection view can attempt to initiate a drag for the given event and items. If the delegate does not implement this method, the collection view will act as if it returned YES.
 */
/*
- (BOOL)collectionView:(NSCollectionView *)collectionView canDragItemsAtIndexes:(NSIndexSet *)indexes withEvent:(NSEvent *)event AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_68#>
}
*/
/*
 This method is called after it has been determined that a drag should begin, but before the drag has been started. To refuse the drag, return NO. To start the drag, declare the pasteboard types that you support with -[NSPasteboard declareTypes:owner:], place your data for the items at the given indexes on the pasteboard, and return YES from the method. The drag image and other drag related information will be set up and provided by the view once this call returns YES. You need to implement this method for your collection view to be a drag source.
 */
/*
- (BOOL)collectionView:(NSCollectionView *)collectionView writeItemsAtIndexes:(NSIndexSet *)indexes toPasteboard:(NSPasteboard *)pasteboard AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_69#>
}
*/
/* The delegate can support file promise drags by adding NSFilesPromisePboardType to the pasteboard in -collectionView:writeItemsAtIndexes:toPasteboard:. NSCollectionView implements -namesOfPromisedFilesDroppedAtDestination: to return the results of this delegate method. This method should return an array of filenames (not full paths) for the created files. The URL represents the drop location. For more information on file promise dragging, see documentation for the NSDraggingSource protocol and -namesOfPromisedFilesDroppedAtDestination:. You do not need to implement this method for your collection view to be a drag source.
 */
/*
- (NSArray *)collectionView:(NSCollectionView *)collectionView namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropURL forDraggedItemsAtIndexes:(NSIndexSet *)indexes AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_70#>
}
*/
/* Allows the delegate to construct a custom dragging image for the items being dragged. 'indexes' contains the indexes of the items being dragged. 'event' is a reference to the  mouse down event that began the drag. 'dragImageOffset' is an in/out parameter. This method will be called with dragImageOffset set to NSZeroPoint, but it can be modified to re-position the returned image. A dragImageOffset of NSZeroPoint will cause the image to be centered under the mouse. You can safely call -[NSCollectionView draggingImageForItemsAtIndexes:withEvent:offset:] from within this method. You do not need to implement this method for your collection view to be a drag source.
 */
/*
- (NSImage *)collectionView:(NSCollectionView *)collectionView draggingImageForItemsAtIndexes:(NSIndexSet *)indexes withEvent:(NSEvent *)event offset:(NSPointPointer)dragImageOffset AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_71#>
}
*/
/* This method is used by the collection view to determine a valid drop target. Based on the mouse position, the collection view will suggest a proposed index and drop operation. These values are in/out parameters and can be changed by the delegate to retarget the drop operation. The collection view will propose NSCollectionViewDropOn when the dragging location is closer to the middle of the item than either of its edges. Otherwise, it will propose NSCollectionViewDropBefore. You may override this default behavior by changing proposedDropOperation or proposedDropIndex. This method must return a value that indicates which dragging operation the data source will perform. It must return something other than NSDragOperationNone to accept the drop.
 
    Note: to receive drag messages, you must first send -registerForDraggedTypes: to the collection view with the drag types you want to support (typically this is done in -awakeFromNib). You must implement this method for your collection view to be a drag destination.
 */
/*
- (NSDragOperation)collectionView:(NSCollectionView *)collectionView validateDrop:(id <NSDraggingInfo>)draggingInfo proposedIndex:(NSInteger *)proposedDropIndex dropOperation:(NSCollectionViewDropOperation *)proposedDropOperation AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_72#>
}
*/
/* This method is called when the mouse is released over a collection view that previously decided to allow a drop via the above validateDrop method. At this time, the delegate should incorporate the data from the dragging pasteboard and update the collection view's contents. You must implement this method for your collection view to be a drag destination.
 */
/*
- (BOOL)collectionView:(NSCollectionView *)collectionView acceptDrop:(id <NSDraggingInfo>)draggingInfo index:(NSInteger)index dropOperation:(NSCollectionViewDropOperation)dropOperation AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_73#>
}
*/
";
	},

	// 
	// Protocol NSColorPickingDefault
	// 
	{
		Identifier = objc.protocols10_6.NSColorPickingDefault;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSColorPickingDefault implementation (MacOSX 10.6)";
		CompletionPrefix = "NSColorPickingDefault";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSColorPickingDefault implementation
//

/* 
    The following methods are implemented by the generic base class, NSColorPicker, and only need be implemented (overridden) by the CustomPicker developer if there is a need.
*/
/* 
    initWithPickerMask:colorPanel: allows you to return your custom color picker to the ColorPanel.

    \"mask\" is the mask (if any) passed to the ColorPanel by the +setPickerMask: method.  If your picker supports any of the bits in the mask, return \"self\", otherwise, return \"nil\" (default is \"self\" if not overridden, since if the \"setPickerMask\" method is never called, the ColorPanel will just start off with the normal picker modes, of which your custom mode will not be a part). This method can be used to turn off some (or all) of your subpickers, if you have any (like sliders). If this method returns \"nil\", the object will be freed.
 
    \"owningColorPanel\" is the id of the instantiating ColorPanel.  
 
    If this method is overridden, the base class' (NSColorPicker's) initFromPickerMask method should be called before any subclass processing. The instance variable \"colorPanel\" is set in this method.
 
    FOR PERFORMANCE, DO NOT LOAD .NIBS, ETC. HERE!! WAIT UNTIL provideNewView: in NSColorPickingCustom!
*/
- (id)initWithPickerMask:(NSUInteger)mask colorPanel:(NSColorPanel *)owningColorPanel
{
	// required method
	<#statements_74#>
}
/* Allows you to return a new image used in the toolbar. By default, you can simply have a .tiff file with the same name as your custom color picker class in the bundle, and will not need to implement this method. 
*/
- (NSImage *)provideNewButtonImage
{
	// required method
	<#statements_75#>
}
- (void)insertNewButtonImage:(NSImage *)newButtonImage in:(NSButtonCell *)buttonCell
{
	// required method
	<#statements_76#>
}
- (void)viewSizeChanged:(id)sender
{
	// required method
	<#statements_77#>
}
- (void)alphaControlAddedOrRemoved:(id)sender
{
	// required method
	<#statements_78#>
}
- (void)attachColorList:(NSColorList *)colorList
{
	// required method
	<#statements_79#>
}
- (void)detachColorList:(NSColorList *)colorList
{
	// required method
	<#statements_80#>
}
- (void)setMode:(NSColorPanelMode)mode
{
	// required method
	<#statements_81#>
}
/* The tooltip to be used for the tool bar button.
*/
- (NSString *)buttonToolTip
{
	// required method
	<#statements_82#>
}
/* The minimum content size for your picker. The NSColorPanel will not allow resizing smaller than this size. By default, you will not have to do anything if you properly setup the Autosizing attributes in IB for your view. 
*/
- (NSSize)minContentSize
{
	// required method
	<#statements_83#>
}
";
	},

	// 
	// Protocol NSColorPickingCustom
	// 
	{
		Identifier = objc.protocols10_6.NSColorPickingCustom;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSColorPickingCustom implementation (MacOSX 10.6)";
		CompletionPrefix = "NSColorPickingCustom";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSColorPickingCustom implementation
//

/* Return NO if \"mode\" not supported. 
*/
- (BOOL)supportsMode:(NSColorPanelMode)mode
{
	// required method
	<#statements_84#>
}
/* Return the current mode that your picker is in.
*/
- (NSColorPanelMode)currentMode
{
	// required method
	<#statements_85#>
}
/* Provide the view for your picker. initialRequest will be YES on very first call. At this point, you should load your nibs.
*/
- (NSView *)provideNewView:(BOOL)initialRequest
{
	// required method
	<#statements_86#>
}
/* Set your color picker's displayed color to newColor.
*/
- (void)setColor:(NSColor *)newColor
{
	// required method
	<#statements_87#>
}
";
	},

	// 
	// Protocol NSComboBoxDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSComboBoxDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSComboBoxDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSComboBoxDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSComboBoxDelegate implementation
//

/* Notifications */
/*
- (void)comboBoxWillPopUp:(NSNotification *)notification
{
	// optional method
	<#statements_88#>
}
*/
/*
- (void)comboBoxWillDismiss:(NSNotification *)notification
{
	// optional method
	<#statements_89#>
}
*/
/*
- (void)comboBoxSelectionDidChange:(NSNotification *)notification
{
	// optional method
	<#statements_90#>
}
*/
/*
- (void)comboBoxSelectionIsChanging:(NSNotification *)notification
{
	// optional method
	<#statements_91#>
}
*/
";
	},

	// 
	// Protocol NSDatePickerCellDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSDatePickerCellDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSDatePickerCellDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSDatePickerCellDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSDatePickerCellDelegate implementation
//

/*
- (void)datePickerCell:(NSDatePickerCell *)aDatePickerCell validateProposedDateValue:(NSDate **)proposedDateValue timeInterval:(NSTimeInterval *)proposedTimeInterval
{
	// optional method
	<#statements_92#>
}
*/
";
	},

	// 
	// Protocol NSDockTilePlugIn
	// 
	{
		Identifier = objc.protocols10_6.NSDockTilePlugIn;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSDockTilePlugIn implementation (MacOSX 10.6)";
		CompletionPrefix = "NSDockTilePlugIn";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSDockTilePlugIn implementation
//

- (void)setDockTile:(NSDockTile*)dockTile
{
	// required method
	<#statements_93#>
}
/*
- (NSMenu*)dockMenu
{
	// optional method
	<#statements_94#>
}
*/
";
	},

	// 
	// Protocol NSDraggingInfo
	// 
	{
		Identifier = objc.protocols10_6.NSDraggingInfo;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSDraggingInfo implementation (MacOSX 10.6)";
		CompletionPrefix = "NSDraggingInfo";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSDraggingInfo implementation
//

- (NSWindow *)draggingDestinationWindow
{
	// required method
	<#statements_95#>
}
- (NSDragOperation)draggingSourceOperationMask
{
	// required method
	<#statements_96#>
}
- (NSPoint)draggingLocation
{
	// required method
	<#statements_97#>
}
- (NSPoint)draggedImageLocation
{
	// required method
	<#statements_98#>
}
- (NSImage *)draggedImage
{
	// required method
	<#statements_99#>
}
- (NSPasteboard *)draggingPasteboard
{
	// required method
	<#statements_100#>
}
- (id)draggingSource
{
	// required method
	<#statements_101#>
}
- (NSInteger)draggingSequenceNumber
{
	// required method
	<#statements_102#>
}
- (void)slideDraggedImageTo:(NSPoint)screenPoint
{
	// required method
	<#statements_103#>
}
- (NSArray *)namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropDestination
{
	// required method
	<#statements_104#>
}
";
	},

	// 
	// Protocol NSImageDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSImageDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSImageDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSImageDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSImageDelegate implementation
//

/*
- (NSImage *)imageDidNotDraw:(id)sender inRect:(NSRect)aRect
{
	// optional method
	<#statements_105#>
}
*/
/*
- (void)image:(NSImage*)image willLoadRepresentation:(NSImageRep*)rep
{
	// optional method
	<#statements_106#>
}
*/
/*
- (void)image:(NSImage*)image didLoadRepresentationHeader:(NSImageRep*)rep
{
	// optional method
	<#statements_107#>
}
*/
/*
- (void)image:(NSImage*)image didLoadPartOfRepresentation:(NSImageRep*)rep withValidRows:(NSInteger)rows
{
	// optional method
	<#statements_108#>
}
*/
/*
- (void)image:(NSImage*)image didLoadRepresentation:(NSImageRep*)rep withStatus:(NSImageLoadStatus)status
{
	// optional method
	<#statements_109#>
}
*/
";
	},

	// 
	// Protocol NSTextInput
	// 
	{
		Identifier = objc.protocols10_6.NSTextInput;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSTextInput implementation (MacOSX 10.6)";
		CompletionPrefix = "NSTextInput";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSTextInput implementation
//

- (void) insertText:(id)aString
{
	// required method
	// instead of keyDown: aString can be NSString or NSAttributedString
	<#statements_110#>
}
- (void) doCommandBySelector:(SEL)aSelector
{
	// required method
	<#statements_111#>
}
- (void) setMarkedText:(id)aString selectedRange:(NSRange)selRange
{
	// required method
	<#statements_112#>
}
- (void) unmarkText
{
	// required method
	<#statements_113#>
}
- (BOOL) hasMarkedText
{
	// required method
	<#statements_114#>
}
- (NSInteger) conversationIdentifier
{
	// required method
	<#statements_115#>
}
/* Returns attributed string at the range.  This allows input mangers to query any range in backing-store.  May return nil.
*/
- (NSAttributedString *) attributedSubstringFromRange:(NSRange)theRange
{
	// required method
	<#statements_116#>
}
/* This method returns the range for marked region.  If hasMarkedText == false, it'll return NSNotFound location & 0 length range.
*/
- (NSRange) markedRange
{
	// required method
	<#statements_117#>
}
/* This method returns the range for selected region.  Just like markedRange method, its location field contains char index from the text beginning.
*/
- (NSRange) selectedRange
{
	// required method
	<#statements_118#>
}
/* This method returns the first frame of rects for theRange in screen coordindate system.
*/
- (NSRect) firstRectForCharacterRange:(NSRange)theRange
{
	// required method
	<#statements_119#>
}
/* This method returns the index for character that is nearest to thePoint.  thPoint is in screen coordinate system.
*/
- (NSUInteger)characterIndexForPoint:(NSPoint)thePoint
{
	// required method
	<#statements_120#>
}
/* This method is the key to attribute extension.  We could add new attributes through this method. NSInputServer examines the return value of this method & constructs appropriate attributed string.
*/
- (NSArray*) validAttributesForMarkedText
{
	// required method
	<#statements_121#>
}
";
	},

	// 
	// Protocol NSInputServiceProvider
	// 
	{
		Identifier = objc.protocols10_6.NSInputServiceProvider;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSInputServiceProvider implementation (MacOSX 10.6)";
		CompletionPrefix = "NSInputServiceProvider";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSInputServiceProvider implementation
//

- (void) insertText:(id)aString client:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_122#>
}
- (void) doCommandBySelector:(SEL)aSelector client:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_123#>
}
- (void) markedTextAbandoned:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_124#>
}
- (void) markedTextSelectionChanged:(NSRange)newSel client:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_125#>
}
- (void) terminate:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_126#>
}
/* Normally canBeDisabled returns YES and is implemented that way in the abstract NSInputServer class.
*/
- (BOOL) canBeDisabled DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_127#>
}
/* Many existing input servers have built-in key bindings that affect what happens within the marked region.  If such an input server wants to handle ALL key events through insertText:client:conversation: and never receive doCommandBySelector:client:conversation:, then it should respond (consistently) YES to this method.  The default is NO.  The processing of incoming events looks at this flag as reflected in the corresponding NSInputManager, before deciding how to deal with events.  A module which responds YES to this method must be prepared to deal with arbitrary strings of Unicode characters under all circumstances whenever it is active.
*/
- (BOOL) wantsToInterpretAllKeystrokes DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_128#>
}
/* Input servers that wants to receive mouse notifications should return YES & implement NSInputServerMouseTrackers protocol */
- (BOOL) wantsToHandleMouseEvents DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_129#>
}
/* This should return YES when the input method (language) prefers to delay text change notification 'till the input is actually committed.
*/
- (BOOL) wantsToDelayTextChangeNotifications DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_130#>
}
/* These methods are sent by current input manager when the application changes state so that the server can update its concept of who's current.  The actually \"active\" sender is the last one to have sent a senderDidBecomeActive: message.  They may not arrive in the expected order.
*/
- (void) inputClientBecomeActive:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_131#>
}
- (void) inputClientResignActive:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_132#>
}
/* These methods are sent by current input manger when it's enabled & the server returns YES to canBeDisabled.  When disabled, the server is expected to send only insertText: or doCommandBySelector:.
*/
- (void) inputClientEnabled:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_133#>
}
- (void) inputClientDisabled:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_134#>
}
/* These methods are sent by input manager when the conversation within a particular sender changes.
*/
- (void) activeConversationWillChange:(id)sender fromOldConversation:(NSInteger)oldConversation DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_135#>
}
- (void) activeConversationChanged:(id)sender toNewConversation:(NSInteger)newConversation DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_136#>
}
";
	},

	// 
	// Protocol NSInputServerMouseTracker
	// 
	{
		Identifier = objc.protocols10_6.NSInputServerMouseTracker;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSInputServerMouseTracker implementation (MacOSX 10.6)";
		CompletionPrefix = "NSInputServerMouseTracker";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSInputServerMouseTracker implementation
//

- (BOOL) mouseDownOnCharacterIndex:(NSUInteger)theIndex atCoordinate:(NSPoint)thePoint withModifier:(NSUInteger)theFlags client:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_137#>
}
- (BOOL) mouseDraggedOnCharacterIndex:(NSUInteger)theIndex atCoordinate:(NSPoint)thePoint withModifier:(NSUInteger)theFlags client:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_138#>
}
- (void) mouseUpOnCharacterIndex:(NSUInteger)theIndex atCoordinate:(NSPoint)thePoint withModifier:(NSUInteger)theFlags client:(id)sender DEPRECATED_IN_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// required method
	<#statements_139#>
}
";
	},

	// 
	// Protocol NSOutlineViewDataSource
	// 
	{
		Identifier = objc.protocols10_6.NSOutlineViewDataSource;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSOutlineViewDataSource implementation (MacOSX 10.6)";
		CompletionPrefix = "NSOutlineViewDataSource";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSOutlineViewDataSource implementation
//

/* Required methods
*/
/*
- (id)outlineView:(NSOutlineView *)outlineView child:(NSInteger)index ofItem:(id)item
{
	// optional method
	<#statements_140#>
}
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView isItemExpandable:(id)item
{
	// optional method
	<#statements_141#>
}
*/
/*
- (NSInteger)outlineView:(NSOutlineView *)outlineView numberOfChildrenOfItem:(id)item
{
	// optional method
	<#statements_142#>
}
*/
/*
- (id)outlineView:(NSOutlineView *)outlineView objectValueForTableColumn:(NSTableColumn *)tableColumn byItem:(id)item
{
	// optional method
	<#statements_143#>
}
*/
/* Optional Methods
*/
/*
- (void)outlineView:(NSOutlineView *)outlineView setObjectValue:(id)object forTableColumn:(NSTableColumn *)tableColumn byItem:(id)item
{
	// optional method
	<#statements_144#>
}
*/
/*
- (id)outlineView:(NSOutlineView *)outlineView itemForPersistentObject:(id)object
{
	// optional method
	<#statements_145#>
}
*/
/*
- (id)outlineView:(NSOutlineView *)outlineView persistentObjectForItem:(id)item
{
	// optional method
	<#statements_146#>
}
*/
/* Optional - Sorting Support
    This is the indication that sorting needs to be done. Typically the data source will sort its data, reload, and adjust selections.
*/
/*
- (void)outlineView:(NSOutlineView *)outlineView sortDescriptorsDidChange:(NSArray *)oldDescriptors AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
{
	// optional method
	<#statements_147#>
}
*/
/* Optional - Drag and Drop support
*/
/* This method is called after it has been determined that a drag should begin, but before the drag has been started.  To refuse the drag, return NO.  To start a drag, return YES and place the drag data onto the pasteboard (data, owner, etc...).  The drag image and other drag related information will be set up and provided by the outline view once this call returns with YES.  The items array is the list of items that will be participating in the drag.
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView writeItems:(NSArray *)items toPasteboard:(NSPasteboard *)pasteboard
{
	// optional method
	<#statements_148#>
}
*/
/* This method is used by NSOutlineView to determine a valid drop target. Based on the mouse position, the outline view will suggest a proposed child 'index' for the drop to happen as a child of 'item'. This method must return a value that indicates which NSDragOperation the data source will perform. The data source may \"re-target\" a drop, if desired, by calling setDropItem:dropChildIndex: and returning something other than NSDragOperationNone. One may choose to re-target for various reasons (eg. for better visual feedback when inserting into a sorted position). On Leopard linked applications, this method is called only when the drag position changes or the dragOperation changes (ie: a modifier key is pressed). Prior to Leopard, it would be called constantly in a timer, regardless of attribute changes.
*/
/*
- (NSDragOperation)outlineView:(NSOutlineView *)outlineView validateDrop:(id <NSDraggingInfo>)info proposedItem:(id)item proposedChildIndex:(NSInteger)index
{
	// optional method
	<#statements_149#>
}
*/
/* This method is called when the mouse is released over an outline view that previously decided to allow a drop via the validateDrop method. The data source should incorporate the data from the dragging pasteboard at this time. 'index' is the location to insert the data as a child of 'item', and are the values previously set in the validateDrop: method.
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView acceptDrop:(id <NSDraggingInfo>)info item:(id)item childIndex:(NSInteger)index
{
	// optional method
	<#statements_150#>
}
*/
/* NSOutlineView data source objects can support file promised drags via by adding  NSFilesPromisePboardType to the pasteboard in outlineView:writeItems:toPasteboard:.  NSOutlineView implements -namesOfPromisedFilesDroppedAtDestination: to return the results of this data source method.  This method should returns an array of filenames for the created files (filenames only, not full paths).  The URL represents the drop location.  For more information on file promise dragging, see documentation on the NSDraggingSource protocol and -namesOfPromisedFilesDroppedAtDestination:.
*/
/*
- (NSArray *)outlineView:(NSOutlineView *)outlineView namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropDestination forDraggedItems:(NSArray *)items AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER
{
	// optional method
	<#statements_151#>
}
*/
";
	},

	// 
	// Protocol NSOutlineViewDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSOutlineViewDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSOutlineViewDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSOutlineViewDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSOutlineViewDelegate implementation
//

/* NSOutlineView replacements for NSTableView delegate methods.
*/
/*
- (void)outlineView:(NSOutlineView *)outlineView willDisplayCell:(id)cell forTableColumn:(NSTableColumn *)tableColumn item:(id)item
{
	// optional method
	<#statements_152#>
}
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView shouldEditTableColumn:(NSTableColumn *)tableColumn item:(id)item
{
	// optional method
	<#statements_153#>
}
*/
/*
- (BOOL)selectionShouldChangeInOutlineView:(NSOutlineView *)outlineView
{
	// optional method
	<#statements_154#>
}
*/
/* Optional - Return YES if 'item' should be selected and 'NO' if it should not. For better performance, and greater control, it is recommended that you use outlineView:selectionIndexesForProposedSelection:. 
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView shouldSelectItem:(id)item
{
	// optional method
	<#statements_155#>
}
*/
/* Optional - Return a set of new indexes to select when the user changes the selection with the keyboard or mouse. If implemented, this method will be called instead of outlineView:shouldSelectItem:. This method may be called multiple times with one new index added to the existing selection to find out if a particular index can be selected when the user is extending the selection with the keyboard or mouse. Note that 'proposedSelectionIndexes' will contain the entire newly suggested selection, and you can return the exsiting selection to avoid changing the selection.
*/
/*
- (NSIndexSet *)outlineView:(NSOutlineView *)outlineView selectionIndexesForProposedSelection:(NSIndexSet *)proposedSelectionIndexes AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_156#>
}
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView shouldSelectTableColumn:(NSTableColumn *)tableColumn
{
	// optional method
	<#statements_157#>
}
*/
/*
- (void)outlineView:(NSOutlineView *)outlineView mouseDownInHeaderOfTableColumn:(NSTableColumn *)tableColumn AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
{
	// optional method
	<#statements_158#>
}
*/
/*
- (void)outlineView:(NSOutlineView *)outlineView didClickTableColumn:(NSTableColumn *)tableColumn AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
{
	// optional method
	<#statements_159#>
}
*/
/*
- (void)outlineView:(NSOutlineView *)outlineView didDragTableColumn:(NSTableColumn *)tableColumn AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
{
	// optional method
	<#statements_160#>
}
*/
/* Optional - Tool Tip support
    When the user pauses over a cell, the value returned from this method will be displayed in a tooltip.  'point' represents the current mouse location in view coordinates.  If you don't want a tooltip at that location, return nil or the empty string.  On entry, 'rect' represents the proposed active area of the tooltip.  By default, rect is computed as [cell drawingRectForBounds:cellFrame].  To control the default active area, you can modify the 'rect' parameter.
*/
/*
- (NSString *)outlineView:(NSOutlineView *)outlineView toolTipForCell:(NSCell *)cell rect:(NSRectPointer)rect tableColumn:(NSTableColumn *)tableColumn item:(id)item mouseLocation:(NSPoint)mouseLocation AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER
{
	// optional method
	<#statements_161#>
}
*/
/* Optional - Variable Row Heights
    Implement this method to support a table with varying row heights. The height returned by this method should not include intercell spacing and must be greater than zero. Performance Considerations: For large tables in particular, you should make sure that this method is efficient. NSTableView may cache the values this method returns, but this should NOT be depended on, as all values may not be cached. To signal a row height change, call -noteHeightOfRowsWithIndexesChanged:. For a given row, the same row height should always be returned until -noteHeightOfRowsWithIndexesChanged: is called, otherwise unpredicable results will happen. NSTableView automatically invalidates its entire row height cache in -reloadData, and -noteNumberOfRowsChanged.
 */
/*
- (CGFloat)outlineView:(NSOutlineView *)outlineView heightOfRowByItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER
{
	// optional method
	<#statements_162#>
}
*/
/* Optional - Type select support
    Implement this method if you want to control the string that is used for type selection. You may want to change what is searched for based on what is displayed, or simply return nil for that row and/or column to not be searched. By default, all cells with text in them are searched. The default value when this delegate method is not implemented is [[outlineView preparedCellForColumn:tableColumn row:[outlineView rowForItem:item]] stringValue], and this value can be returned from the delegate method if desired.
*/
/*
- (NSString *)outlineView:(NSOutlineView *)outlineView typeSelectStringForTableColumn:(NSTableColumn *)tableColumn item:(id)item AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_163#>
}
*/
/* Optional - Type select support
    Implement this method if you want to control how type selection works. Return the first item that matches the searchString from within the range of startItem to endItem. It is possible for endItem to be less than startItem if the search will wrap. Return nil when there is no match. Include startItem as a possible match, but do not include endItem. It is not necessary to implement this method in order to support type select.
*/
/*
- (id)outlineView:(NSOutlineView *)outlineView nextTypeSelectMatchFromItem:(id)startItem toItem:(id)endItem forString:(NSString *)searchString AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_164#>
}
*/
/* Optional - Type select support
    Implement this method if you would like to prevent a type select from happening based on the current event and current search string. Generally, this will be called from keyDown: and the event will be a key event. The search string will be nil if no type select has began. 
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView shouldTypeSelectForEvent:(NSEvent *)event withCurrentSearchString:(NSString *)searchString AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_165#>
}
*/
/* Optional - Expansion ToolTip support
    Implement this method and return NO to prevent an expansion tooltip from appearing for a particular cell at 'item' in 'tableColumn'. See NSCell.h for more information on expansion tool tips. 
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView shouldShowCellExpansionForTableColumn:(NSTableColumn *)tableColumn item:(id)item AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_166#>
}
*/
/*  Optional - Custom tracking support
    It is possible to control the ability to track a cell or not. Normally, only selectable or selected cells can be tracked. If you implement this method, cells which are not selectable or selected can be tracked, and vice-versa. For instance, this allows you to have an NSButtonCell in a table which does not change the selection, but can still be clicked on and tracked.
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView shouldTrackCell:(NSCell *)cell forTableColumn:(NSTableColumn *)tableColumn item:(id)item AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_167#>
}
*/
/*  Optional - Different cells for each row
    A different data cell can be returned for any particular tableColumn and item, or a cell that will be used for the entire row (a full width cell). The returned cell should properly implement copyWithZone:, since the cell may be copied by NSTableView. If the tableColumn is non-nil, you should return a cell, and generally you will want to default to returning the result from [tableColumn dataCellForRow:row].

    When each row (identified by the item) is being drawn, this method will first be called with a nil tableColumn. At this time, you can return a cell that will be used to draw the entire row, acting like a group. If you do return a cell for the 'nil' tableColumn, be prepared to have the other corresponding datasource and delegate methods to be called with a 'nil' tableColumn value. If don't return a cell, the method will be called once for each tableColumn in the tableView, as usual.
*/
/*
- (NSCell *)outlineView:(NSOutlineView *)outlineView dataCellForTableColumn:(NSTableColumn *)tableColumn item:(id)item AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_168#>
}
*/
/* Optional - Group rows. 
    Implement this method and return YES to indicate a particular row should have the \"group row\" style drawn for that row. If the cell in that row is an NSTextFieldCell and contains only a stringValue, the \"group row\" style attributes will automatically be applied for that cell. 
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView isGroupItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_169#>
}
*/
/* Optional - Controlling expanding/collapsing of items.
    Called when the outlineView is about to expand 'item'. Implementations of this method should be fast. This method may be called multiple times if a given 'item' has children that are also being expanded. If NO is returned, 'item' will not be expanded, nor will its children (even if -[outlineView expandItem:item expandChildren:YES] is called).
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView shouldExpandItem:(id)item
{
	// optional method
	<#statements_170#>
}
*/
/* Optional - Controlling expanding/collapsing of items.
    Called when the outlineView is about to collapse 'item'. Implementations of this method should be fast. If NO is returned, 'item' will not be collapsed, nor will its children (even if -[outlineView collapseItem:item collapseChildren:YES] is called).
*/
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView shouldCollapseItem:(id)item
{
	// optional method
	<#statements_171#>
}
*/
/* Optional - OutlineCell (disclosure triangle button cell)
    Implement this method to customize the \"outline cell\" used for the disclosure triangle button. customization of the \"outline cell\" used for the disclosure triangle button. For instance, you can cause the button cell to always use a \"dark\" triangle by changing the cell's backgroundStyle with: [cell setBackgroundStyle:NSBackgroundStyleLight]
*/
/*
- (void)outlineView:(NSOutlineView *)outlineView willDisplayOutlineCell:(id)cell forTableColumn:(NSTableColumn *)tableColumn item:(id)item
{
	// optional method
	<#statements_172#>
}
*/
/* Optional - Autosizing table columns
 Implement this method if you want to control how wide a column is made when the user double clicks on the resize divider. By default, NSTableView iterates every row in the table, accesses a cell via preparedCellAtRow:column:, and requests the \"cellSize\" to find the appropriate largest width to use. For large row counts, a monte carlo simulation is done instead of interating every row. For accurate performance, it is recommended that this method is implemented when using large tables. 
*/
/*
- (CGFloat)outlineView:(NSOutlineView *)outlineView sizeToFitWidthOfColumn:(NSInteger)column AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_173#>
}
*/
/*  Optional - Control of column reordering.
 Specifies if the column can be reordered to a new location, or not. 'columnIndex' is the column that is being dragged. The actual NSTableColumn instance can be retrieved from the [tableView tableColumns] array. 'newColumnIndex' is the new proposed target location for 'columnIndex'. When a column is initially dragged by the user, the delegate is first called with a 'newColumnIndex' of -1. Returning NO will disallow that column from being reordered at all. Returning YES allows it to be reordered, and the delegate will be called again when the column reaches a new location. If this method is not implemented, all columns are considered reorderable. 
 */
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView shouldReorderColumn:(NSInteger)columnIndex toColumn:(NSInteger)newColumnIndex AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_174#>
}
*/
/* Optional - Hiding the outline cell (disclosure triangle)
 Allows the delegate to decide if the outline cell (disclosure triangle) for 'item' should be displayed or not. This method will only be called for expandable rows. If 'NO' is returned,  -[outlineView frameOfOutlineCellAtRow:] will return NSZeroRect, causing the outline cell to be hidden. In addition, if 'NO' is returned, the row will not be collapsable by keyboard shortcuts.
 */
/*
- (BOOL)outlineView:(NSOutlineView *)outlineView shouldShowOutlineCellForItem:(id)item AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_175#>
}
*/
";
	},

	// 
	// Protocol NSPasteboardWriting
	// 
	{
		Identifier = objc.protocols10_6.NSPasteboardWriting;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSPasteboardWriting implementation (MacOSX 10.6)";
		CompletionPrefix = "NSPasteboardWriting";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSPasteboardWriting implementation
//

/* Returns an array of UTI strings of data types the receiver can write to the pasteboard.  By default, data for the first returned type is put onto the pasteboard immediately, with the remaining types being promised.  To change the default behavior, implement -writingOptionsForType:pasteboard: and return NSPasteboardWritingPromised to lazily provided data for types, return no option to provide the data for that type immediately.  Use the pasteboard argument to provide different types based on the pasteboard name, if desired.  Do not perform other pasteboard operations in the method implementation.
*/
- (NSArray *)writableTypesForPasteboard:(NSPasteboard *)pasteboard
{
	// required method
	<#statements_176#>
}
/* Returns options for writing data of a type to a pasteboard.  Use the pasteboard argument to provide different options based on the pasteboard name, if desired.  Do not perform other pasteboard operations in the method implementation.
*/
/*
- (NSPasteboardWritingOptions)writingOptionsForType:(NSString *)type pasteboard:(NSPasteboard *)pasteboard
{
	// optional method
	<#statements_177#>
}
*/
/* Returns the appropriate property list object for the provided type.  This will commonly be the NSData for that data type.  However, if this method returns either a string, or any other property-list type, the pasteboard will automatically convert these items to the correct NSData format required for the pasteboard.  
*/
- (id)pasteboardPropertyListForType:(NSString *)type
{
	// required method
	<#statements_178#>
}
";
	},

	// 
	// Protocol NSPasteboardReading
	// 
	{
		Identifier = objc.protocols10_6.NSPasteboardReading;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSPasteboardReading implementation (MacOSX 10.6)";
		CompletionPrefix = "NSPasteboardReading";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSPasteboardReading implementation
//

/* Returns an array of data types as UTI strings that the receiver can read from the pasteboard and be initialized from.  By default, the NSData for the type is provided to -initWithPasteboardPropertyList:ofType:.  By implementing -readingOptionsForType:pasteboard: and specifying a different option, the NSData for that type can be automatically converted to an NSString or property list object before being passed to -readingOptionsForType:pasteboard:.  Use the pasteboard argument to provide different types based on the pasteboard name, if desired.  Do not perform other pasteboard operations in the method implementation.
*/
+ (NSArray *)readableTypesForPasteboard:(NSPasteboard *)pasteboard
{
	// required method
	<#statements_179#>
}
/* Returns options for reading data of a type from a pasteboard.  Use the pasteboard argument to provide different options based on the pasteboard name, if desired.  Do not perform other pasteboard operations in the method implementation. 
*/
/*
+ (NSPasteboardReadingOptions)readingOptionsForType:(NSString *)type pasteboard:(NSPasteboard *)pasteboard
{
	// optional method
	<#statements_180#>
}
*/
/* Initializes an instance with a property list object and a type string.  By default, the property list object is the NSData for that type on the pasteboard.  By specifying an NSPasteboardReading option for a type, the data on the pasteboard can be retrieved and automatically converted to a string or property list instead.  This method is considered optional because if there is a single type returned from +readableTypesForPasteboard, and that type uses the NSPasteboardReadingAsKeyedArchive reading option, then initWithCoder: will be called to initialize a new instance from the keyed archive.
*/
/*
- (id)initWithPasteboardPropertyList:(id)propertyList ofType:(NSString *)type
{
	// optional method
	<#statements_181#>
}
*/
";
	},

	// 
	// Protocol NSPasteboardItemDataProvider
	// 
	{
		Identifier = objc.protocols10_6.NSPasteboardItemDataProvider;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSPasteboardItemDataProvider implementation (MacOSX 10.6)";
		CompletionPrefix = "NSPasteboardItemDataProvider";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSPasteboardItemDataProvider implementation
//

/* Implemented by the data provider of a pasteboard item, to provide the data for a particular UTI type.
*/
- (void)pasteboard:(NSPasteboard *)pasteboard item:(NSPasteboardItem *)item provideDataForType:(NSString *)type
{
	// required method
	<#statements_182#>
}
/* One data provider can provide data for more than one pasteboard item.  This method is called when the pasteboard no longer needs the data provider for any of its pasteboard items.  This can be either because the data provider has fulfilled all promises, or because ownership of the pasteboard has changed.
*/
/*
- (void)pasteboardFinishedWithDataProvider:(NSPasteboard *)pasteboard
{
	// optional method
	<#statements_183#>
}
*/
";
	},

	// 
	// Protocol NSPathControlDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSPathControlDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSPathControlDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSPathControlDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSPathControlDelegate implementation
//

/* Optional dragging source support. This method is called when a drag is about to begin. This method must be implemented to allow dragging from the control. You can refuse to allow the drag to happen by returning NO, and allow it by returning YES. By default, 'pasteboard' automatically have the following types on it: NSStringPboardType, NSURLPboardType (if there is a URL value for the cell being dragged), and NSFilenamesPboardType (if the URL value returns YES from -isFileURL). You can customize the types placed on the pasteboard at this time, if desired.
*/
/*
- (BOOL)pathControl:(NSPathControl *)pathControl shouldDragPathComponentCell:(NSPathComponentCell *)pathComponentCell withPasteboard:(NSPasteboard *)pasteboard
{
	// optional method
	<#statements_184#>
}
*/
/* Optional dragging destination support. This method is called when something is dragged over the control. This method can be implemented to allow dragging onto the control. The delegate method will be called even for instances that are \"disabled\" (ie: return NO from -isEnabled). Return NSDragOperationNone to refuse the drop, or anything else to accept it.

    If not implemented, and the control isEnabled, with the control's cell isEditable, the drop will be accepted if it contains an NSURLPboardType or NSFilenamesPboardType that conforms to the [cell allowedTypes].
*/
/*
- (NSDragOperation)pathControl:(NSPathControl *)pathControl validateDrop:(id <NSDraggingInfo>)info
{
	// optional method
	<#statements_185#>
}
*/
/* Optional dragging destination support. In order to accept the dropped contents previously accepted from validateDrop:, you must implement this method. This method is called from -performDragOperation:. You should change the URL value based on the dragged information.

    If not implemented, and the control's cell isEditable, the drop will be accepted if it contains an NSURLPboardType or NSFilenamesPboardType that conforms to the [cell allowedTypes]. The cell's URL value will automatically be changed, and the action will be invoked.

*/
/*
- (BOOL)pathControl:(NSPathControl *)pathControl acceptDrop:(id <NSDraggingInfo>)info
{
	// optional method
	<#statements_186#>
}
*/
/* The following two optional methods are described in NSPathCell's delegate. By default, the cell's delegate is set to the control, and the cell's delegate methods are delegated to the control's delegate.
*/
/* Called before the 'openPanel' is shown, but after the 'openPanel' has allowedFileTypes set to the cell's allowedTypes. At this time, you can further customize the 'openPanel' as required. This is only ever called when the style is set to NSPathStylePopUp.
*/
/*
- (void)pathControl:(NSPathControl *)pathControl willDisplayOpenPanel:(NSOpenPanel *)openPanel
{
	// optional method
	<#statements_187#>
}
*/
/* Called before the 'menu' is shown. At this time, you can further customize the 'menu' as required, adding and removing items. This is only ever called when the style is set to NSPathStylePopUp.
*/
/*
- (void)pathControl:(NSPathControl *)pathControl willPopUpMenu:(NSMenu *)menu
{
	// optional method
	<#statements_188#>
}
*/
";
	},

	// 
	// Protocol NSPrintPanelAccessorizing
	// 
	{
		Identifier = objc.protocols10_6.NSPrintPanelAccessorizing;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSPrintPanelAccessorizing implementation (MacOSX 10.6)";
		CompletionPrefix = "NSPrintPanelAccessorizing";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSPrintPanelAccessorizing implementation
//

/* Return the text that summarizes the settings that the user has chosen using this print panel accessory view and that should appear in the summary pane of the print panel. It must be an array of dictionaries (not nil), each of which has an NSPrintPanelAccessorySummaryItemNameKey entry and an NSPrintPanelAccessorySummaryItemDescriptionKey entry whose values are strings. A print panel accessory view must be KVO-compliant for \"localizedSummaryItems\" because NSPrintPanel observes it to keep what it displays in its Summary view up to date. (In Mac OS 10.5 there is no way for the user to see your accessory view and the Summary view at the same time, but that might not always be true in the future.)
*/
- (NSArray *)localizedSummaryItems
{
	// required method
	<#statements_189#>
}
/* Return the key paths for properties whose values affect what is drawn in the print panel's built-in preview. NSPrintPanel observes these key paths and redraws the preview when the values for any of them change. For example, if you write an accessory view that lets the user change document margins in the print panel you might provide an implementation of this method that returns a set that includes strings like @\"representedObject.leftMargin\", @\"representedObject.rightMargin\", etc. (because the representedObject would be an NSPrintInfo, which is KVO-compliant for \"leftMargin,\" \"rightMargin,\" etc.). This protocol method is optional because it's not necessary if you're not using NSPrintPanel's built-in preview, but if you use preview you almost certainly have to implement this method properly too.
*/
/*
- (NSSet *)keyPathsForValuesAffectingPreview
{
	// optional method
	<#statements_190#>
}
*/
";
	},

	// 
	// Protocol NSOpenSavePanelDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSOpenSavePanelDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSOpenSavePanelDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSOpenSavePanelDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSOpenSavePanelDelegate implementation
//

/* Optional - enabled URLs.
    NSOpenPanel: Return YES to allow the 'url' to be enabled in the panel. Delegate implementations should be fast to avoid stalling the UI.
    NSSavePanel: This method is not called; all urls are always disabled.
 */
/*
- (BOOL)panel:(id)sender shouldEnableURL:(NSURL *)url AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_191#>
}
*/
/* Optional - URL validation for saving and opening files. 
    NSSavePanel: The method is called once by the save panel when the user chooses the Save button. The user is intending to save a file at 'url'. Return YES if the 'url' is a valid location to save to. Note that an item at 'url' may not physically exist yet, unless the user decided to overwrite an existing item. Return NO and fill in the 'outError' with a user displayable error message for why the 'url' is not valid. If a recovery option is provided by the error, and recovery succeeded, the panel will attempt to close again.
    NSOpenPanel: The method is called once for each selected filename (or directory) when the user chooses the Open button. Return YES if the 'url' is acceptable to open. Return NO and fill in the 'outError' with a user displayable message for why the 'url' is not valid for opening. You would use this method over panel:shouldEnableURL: if the processing of the selected item takes a long time. If a recovery option is provided by the error, and recovery succeeded, the panel will attempt to close again.
 */
/*
- (BOOL)panel:(id)sender validateURL:(NSURL *)url error:(NSError **)outError AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_192#>
}
*/
/* Optional - Sent when the user has changed the selected directory to the directory located at 'url'. 'url' may be nil, if the current directory can't be represented by an NSURL object (ie: the media sidebar directory, or the \"Computer\").
 */
/*
- (void)panel:(id)sender didChangeToDirectoryURL:(NSURL *)url AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_193#>
}
*/
/* Optional - Filename customization for the NSSavePanel. Allows the delegate to customize the filename entered by the user, before the extension is appended, and before the user is potentially asked to replace a file.
 */
/*
- (NSString *)panel:(id)sender userEnteredFilename:(NSString *)filename confirmed:(BOOL)okFlag
{
	// optional method
	<#statements_194#>
}
*/
/* Optional - Sent when the user clicks the disclosure triangle to expand or collapse the file browser while in NSOpenPanel.
 */
/*
- (void)panel:(id)sender willExpand:(BOOL)expanding
{
	// optional method
	<#statements_195#>
}
*/
/* Optional - Sent when the user has changed the selection.
 */
/*
- (void)panelSelectionDidChange:(id)sender AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
{
	// optional method
	<#statements_196#>
}
*/
";
	},

	// 
	// Protocol NSSoundDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSSoundDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSSoundDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSSoundDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSSoundDelegate implementation
//

/*
- (void)sound:(NSSound *)sound didFinishPlaying:(BOOL)aBool
{
	// optional method
	<#statements_197#>
}
*/
";
	},

	// 
	// Protocol NSSpeechRecognizerDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSSpeechRecognizerDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSSpeechRecognizerDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSSpeechRecognizerDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSSpeechRecognizerDelegate implementation
//

/*
- (void)speechRecognizer:(NSSpeechRecognizer *)sender didRecognizeCommand:(id)command
{
	// optional method
	<#statements_198#>
}
*/
";
	},

	// 
	// Protocol NSSpeechSynthesizerDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSSpeechSynthesizerDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSSpeechSynthesizerDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSSpeechSynthesizerDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSSpeechSynthesizerDelegate implementation
//

/*
- (void)speechSynthesizer:(NSSpeechSynthesizer *)sender didFinishSpeaking:(BOOL)finishedSpeaking
{
	// optional method
	<#statements_199#>
}
*/
/*
- (void)speechSynthesizer:(NSSpeechSynthesizer *)sender willSpeakWord:(NSRange)characterRange ofString:(NSString *)string
{
	// optional method
	<#statements_200#>
}
*/
/*
- (void)speechSynthesizer:(NSSpeechSynthesizer *)sender willSpeakPhoneme:(short)phonemeOpcode
{
	// optional method
	<#statements_201#>
}
*/
/*
- (void)speechSynthesizer:(NSSpeechSynthesizer *)sender didEncounterErrorAtIndex:(NSUInteger)characterIndex ofString:(NSString *)string message:(NSString *)message
{
	// optional method
	<#statements_202#>
}
*/
/*
- (void)speechSynthesizer:(NSSpeechSynthesizer *)sender didEncounterSyncMessage:(NSString *)message
{
	// optional method
	<#statements_203#>
}
*/
";
	},

	// 
	// Protocol NSChangeSpelling
	// 
	{
		Identifier = objc.protocols10_6.NSChangeSpelling;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSChangeSpelling implementation (MacOSX 10.6)";
		CompletionPrefix = "NSChangeSpelling";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSChangeSpelling implementation
//

- (void)changeSpelling:(id)sender
{
	// required method
	<#statements_204#>
}
";
	},

	// 
	// Protocol NSIgnoreMisspelledWords
	// 
	{
		Identifier = objc.protocols10_6.NSIgnoreMisspelledWords;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSIgnoreMisspelledWords implementation (MacOSX 10.6)";
		CompletionPrefix = "NSIgnoreMisspelledWords";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSIgnoreMisspelledWords implementation
//

- (void)ignoreSpelling:(id)sender
{
	// required method
	<#statements_205#>
}
";
	},

	// 
	// Protocol NSSplitViewDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSSplitViewDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSSplitViewDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSSplitViewDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSSplitViewDelegate implementation
//

/* Divider indices are zero-based, with the topmost (in horizontal split views) or leftmost (vertical) divider having an index of 0.
*/
/* Return YES if a subview can be collapsed, NO otherwise. If a split view has no delegate, or if its delegate does not respond to this message, none of the split view's subviews can be collapsed. If a split view has a delegate, and the delegate responds to this message, it will be sent at least twice when the user clicks or double-clicks on one of the split view's dividers, once per subview on either side of the divider, and may be resent as the user continues to drag the divider. If a subview is collapsible, the current implementation of NSSplitView will collapse it when the user has dragged the divider more than halfway between the position that would make the subview its minimum size and the position that would make it zero size. The subview will become uncollapsed if the user drags the divider back past that point. The comments for -splitView:constrainMinCoordinate:ofSubviewAt: and -splitView:constrainMaxCoordinate:ofSubviewAt: describe how subviews' minimum sizes are determined. Collapsed subviews are hidden but retained by the split view. Collapsing of a subview will not change its bounds, but may set its frame to zero pixels high (in horizontal split views) or zero pixels wide (vertical).
*/
/*
- (BOOL)splitView:(NSSplitView *)splitView canCollapseSubview:(NSView *)subview
{
	// optional method
	<#statements_206#>
}
*/
/* Return YES if the subview should be collapsed because the user has double-clicked on an adjacent divider. If a split view has a delegate, and the delegate responds to this message, it will be sent once for the subview before a divider when the user double-clicks on that divider, and again for the subview after the divider, but only if the delegate returned YES when sent -splitView:canCollapseSubview: for the subview in question. When the delegate indicates that both subviews should be collapsed NSSplitView's behavior is undefined.
*/
/*
- (BOOL)splitView:(NSSplitView *)splitView shouldCollapseSubview:(NSView *)subview forDoubleClickOnDividerAtIndex:(NSInteger)dividerIndex
{
	// optional method
	<#statements_207#>
}
*/
/* Given a proposed minimum allowable position for one of the dividers of a split view, return the minimum allowable position for the divider. If a split view has no delegate, or if its delegate does not respond to this message, the split view behaves as if it has a delegate that responds to this message by merely returning the proposed minimum. If a split view has a delegate, and the delegate responds to this message, it will be sent at least once when the user begins dragging one of the split view's dividers, and may be resent as the user continues to drag the divider.

Delegates that respond to this message and return a number larger than the proposed minimum position effectively declare a minimum size for the subview above or to the left of the divider in question, the minimum size being the difference between the proposed and returned minimum positions. This minimum size is only effective for the divider-dragging operation during which the -splitView:constrainMinCoordinate:ofSubviewAt: message is sent. NSSplitView's behavior is undefined when a delegate responds to this message by returning a number smaller than the proposed minimum.
*/
/*
- (CGFloat)splitView:(NSSplitView *)splitView constrainMinCoordinate:(CGFloat)proposedMinimumPosition ofSubviewAt:(NSInteger)dividerIndex
{
	// optional method
	<#statements_208#>
}
*/
/* Given a proposed maximum allowable position for one of the dividers of a split view, return the maximum allowable position for the divider. If a split view has no delegate, or if its delegate does not respond to this message, the split view behaves as if it has a delegate that responds to this message by merely returning the proposed maximum. If a split view has a delegate, and the delegate responds to this message, it will be sent at least once when the user begins dragging one of the split view's dividers, and may be resent as the user continues to drag the divider.

Delegates that respond to this message and return a number smaller than the proposed maximum position effectively declare a minimum size for the subview below or to the right of the divider in question, the minimum size being the difference between the proposed and returned maximum positions. This minimum size is only effective for the divider-dragging operation during which the -splitView:constrainMaxCoordinate:ofSubviewAt: message is sent. NSSplitView's behavior is undefined when a delegate responds to this message by returning a number larger than the proposed maximum.
*/
/*
- (CGFloat)splitView:(NSSplitView *)splitView constrainMaxCoordinate:(CGFloat)proposedMaximumPosition ofSubviewAt:(NSInteger)dividerIndex
{
	// optional method
	<#statements_209#>
}
*/
/* Given a proposed position for one of the dividers of a split view, return a position at which the divider should be placed as the user drags it. If a split view has no delegate, or if its delegate does not respond to this message, the split view behaves as if it has a delegate that responds to this message by merely returning the proposed position. If a split view has a delegate, and the delegate responds to this message, it will be sent repeatedly as the user drags one of the split view's dividers.
*/
/*
- (CGFloat)splitView:(NSSplitView *)splitView constrainSplitPosition:(CGFloat)proposedPosition ofSubviewAt:(NSInteger)dividerIndex
{
	// optional method
	<#statements_210#>
}
*/
/* Given that a split view has been resized but has not yet adjusted its subviews to accomodate the new size, and given the former size of the split view, adjust the subviews to accomodate the new size of the split view. If a split view has no delegate, or if its delegate does not respond to this message, the split view behaves as if it has a delegate that responds to this message by merely sending the split view an -adjustSubviews message.

Delegates that respond to this message should adjust the frames of the uncollapsed subviews so that they exactly fill the split view with room for dividers in between, taking its new size into consideration. The thickness of dividers can be determined by sending the split view a -dividerThickness message.
*/
/*
- (void)splitView:(NSSplitView *)splitView resizeSubviewsWithOldSize:(NSSize)oldSize
{
	// optional method
	<#statements_211#>
}
*/
/* Given that a split view has been resized and is adjusting its subviews to accomodate the new size, return YES if -adjustSubviews can change the size of the indexed subview, NO otherwise. -adjustSubviews may change the origin of the indexed subview regardless of what this method returns. -adjustSubviews may also resize otherwise nonresizable subviews to prevent an invalid subview layout. If a split view has no delegate, or if its delegate does not respond to this message, the split view behaves as if it has a delegate that returns YES when sent this message.
 */
/*
- (BOOL)splitView:(NSSplitView *)splitView shouldAdjustSizeOfSubview:(NSView *)view
{
	// optional method
	<#statements_212#>
}
*/
/* Given that a split view has been resized and is adjusting its subviews to accomodate the new size, or that the user is dragging a divider, return YES to allow the divider to be dragged or adjusted off the edge of the split view where it will not be visible. If a split view has no delegate, or if its delegate does not respond to this message, the split view behaves as if it has a delegate that returns NO when sent this message.
*/
/*
- (BOOL)splitView:(NSSplitView *)splitView shouldHideDividerAtIndex:(NSInteger)dividerIndex
{
	// optional method
	<#statements_213#>
}
*/
/* Given the drawn frame of a divider (in the coordinate system established by the split view's bounds), return the frame in which mouse clicks should initiate divider dragging. If a split view has no delegate, or if its delegate does not respond to this message, the split view behaves as if it has a delegate that returns proposedEffectiveRect when sent this message. A split view with thick dividers proposes the drawn frame as the effective frame. A split view with thin dividers proposes an effective frame that's a litte larger than the drawn frame, to make it easier for the user to actually grab the divider.
*/
/*
- (NSRect)splitView:(NSSplitView *)splitView effectiveRect:(NSRect)proposedEffectiveRect forDrawnRect:(NSRect)drawnRect ofDividerAtIndex:(NSInteger)dividerIndex
{
	// optional method
	<#statements_214#>
}
*/
/* Given a divider index, return an additional rectangular area (in the coordinate system established by the split view's bounds) in which mouse clicks should also initiate divider dragging, or NSZeroRect to not add one. If a split view has no delegate, or if its delegate does not respond to this message, only mouse clicks within the effective frame of a divider initiate divider dragging.
*/
/*
- (NSRect)splitView:(NSSplitView *)splitView additionalEffectiveRectOfDividerAtIndex:(NSInteger)dividerIndex
{
	// optional method
	<#statements_215#>
}
*/
/* Respond as if the delegate had registered for the NSSplitViewDidResizeSubviewsNotification or NSSplitViewWillResizeSubviewsNotification notification, described below. A split view's behavior is not explicitly affected by a delegate's ability or inability to respond to these messages, though the delegate may send messages to the split view in response to these messages.
*/
/*
- (void)splitViewWillResizeSubviews:(NSNotification *)notification
{
	// optional method
	<#statements_216#>
}
*/
/*
- (void)splitViewDidResizeSubviews:(NSNotification *)notification
{
	// optional method
	<#statements_217#>
}
*/
";
	},

	// 
	// Protocol NSTableViewDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSTableViewDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSTableViewDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSTableViewDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSTableViewDelegate implementation
//

/* Allows the delegate to provide further setup for 'cell' in 'tableColumn'/'row'. It is not safe to do drawing inside this method, and you should only setup state for 'cell'.
 */ 
/*
- (void)tableView:(NSTableView *)tableView willDisplayCell:(id)cell forTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row
{
	// optional method
	<#statements_218#>
}
*/
/*
- (BOOL)tableView:(NSTableView *)tableView shouldEditTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row
{
	// optional method
	<#statements_219#>
}
*/
/*
- (BOOL)selectionShouldChangeInTableView:(NSTableView *)tableView
{
	// optional method
	<#statements_220#>
}
*/
/* Optional - Return YES if 'row' should be selected and NO if it should not. For better performance and better control over the selection, you should use tableView:selectionIndexesForProposedSelection:. 
*/
/*
- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(NSInteger)row
{
	// optional method
	<#statements_221#>
}
*/
/* Optional - Return a set of new indexes to select when the user changes the selection with the keyboard or mouse. If implemented, this method will be called instead of tableView:shouldSelectRow:. This method may be called multiple times with one new index added to the existing selection to find out if a particular index can be selected when the user is extending the selection with the keyboard or mouse. Note that 'proposedSelectionIndexes' will contain the entire newly suggested selection, and you can return the exsiting selection to avoid changing the selection.
*/
/*
- (NSIndexSet *)tableView:(NSTableView *)tableView selectionIndexesForProposedSelection:(NSIndexSet *)proposedSelectionIndexes AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_222#>
}
*/
/*
- (BOOL)tableView:(NSTableView *)tableView shouldSelectTableColumn:(NSTableColumn *)tableColumn
{
	// optional method
	<#statements_223#>
}
*/
/*
- (void)tableView:(NSTableView *)tableView mouseDownInHeaderOfTableColumn:(NSTableColumn *)tableColumn
{
	// optional method
	<#statements_224#>
}
*/
/*
- (void)tableView:(NSTableView *)tableView didClickTableColumn:(NSTableColumn *)tableColumn
{
	// optional method
	<#statements_225#>
}
*/
/*
- (void)tableView:(NSTableView *)tableView didDragTableColumn:(NSTableColumn *)tableColumn
{
	// optional method
	<#statements_226#>
}
*/
/* Optional - Tool Tip Support
    When the user pauses over a cell, the value returned from this method will be displayed in a tooltip.  'point' represents the current mouse location in view coordinates.  If you don't want a tooltip at that location, return nil or the empty string.  On entry, 'rect' represents the proposed active area of the tooltip.  By default, rect is computed as [cell drawingRectForBounds:cellFrame].  To control the default active area, you can modify the 'rect' parameter.
*/
/*
- (NSString *)tableView:(NSTableView *)tableView toolTipForCell:(NSCell *)cell rect:(NSRectPointer)rect tableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row mouseLocation:(NSPoint)mouseLocation AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER
{
	// optional method
	<#statements_227#>
}
*/
/* Optional - Variable Row Heights
    Implement this method to support a table with varying row heights. The height returned by this method should not include intercell spacing and must be greater than zero. Performance Considerations: For large tables in particular, you should make sure that this method is efficient. NSTableView may cache the values this method returns, but this should NOT be depended on, as all values may not be cached. To signal a row height change, call -noteHeightOfRowsWithIndexesChanged:. For a given row, the same row height should always be returned until -noteHeightOfRowsWithIndexesChanged: is called, otherwise unpredicable results will happen. NSTableView automatically invalidates its entire row height cache in -reloadData, and -noteNumberOfRowsChanged.
*/
/*
- (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER
{
	// optional method
	<#statements_228#>
}
*/
/* Optional - Type select support
    Implement this method if you want to control the string that is used for type selection. You may want to change what is searched for based on what is displayed, or simply return nil for that 'tableColumn' or 'row' to not be searched. By default, all cells with text in them are searched. The default value when this delegate method is not implemented is [[tableView preparedCellForColumn:tableColumn row:row] stringValue], and this value can be returned from the delegate method if desired.
*/
/*
- (NSString *)tableView:(NSTableView *)tableView typeSelectStringForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_229#>
}
*/
/* Optional - Type select support
    Implement this method if you want to control how type selection works. Return the first row that matches searchString from within the range of startRow to endRow. It is possible for endRow to be less than startRow if the search will wrap. Return -1 when there is no match. Include startRow as a possible match, but do not include endRow. It is not necessary to implement this method in order to support type select.
*/
/*
- (NSInteger)tableView:(NSTableView *)tableView nextTypeSelectMatchFromRow:(NSInteger)startRow toRow:(NSInteger)endRow forString:(NSString *)searchString AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_230#>
}
*/
/* Optional - Type select support
    Implement this method if you would like to prevent a type select from happening based on the current event and current search string. Generally, this will be called from keyDown: and the event will be a key event. The search string will be nil if no type select has began. 
*/
/*
- (BOOL)tableView:(NSTableView *)tableView shouldTypeSelectForEvent:(NSEvent *)event withCurrentSearchString:(NSString *)searchString AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_231#>
}
*/
/* Optional - Expansion ToolTip support
    Implement this method and return NO to prevent an expansion tooltip from appearing for a particular cell in a given row and tableColumn. See NSCell.h for more information on expansion tool tips. 
*/
/*
- (BOOL)tableView:(NSTableView *)tableView shouldShowCellExpansionForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_232#>
}
*/
/*  Optional - Custom tracking support
    It is possible to control the ability to track a cell or not. Normally, only selectable or selected cells can be tracked. If you implement this method, cells which are not selectable or selected can be tracked, and vice-versa. For instance, this allows you to have an NSButtonCell in a table which does not change the selection, but can still be clicked on and tracked.
*/
/*
- (BOOL)tableView:(NSTableView *)tableView shouldTrackCell:(NSCell *)cell forTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_233#>
}
*/
/*  Optional - Different cells for each row
    A different data cell can be returned for any particular tableColumn and row, or a cell that will be used for the entire row (a full width cell). The returned cell should properly implement copyWithZone:, since the cell may be copied by NSTableView. If the tableColumn is non-nil, you should return a cell, and generally you will want to default to returning the result from [tableColumn dataCellForRow:row].

    When each row is being drawn, this method will first be called with a nil tableColumn. At this time, you can return a cell that will be used to draw the entire row, acting like a group. If you do return a cell for the 'nil' tableColumn, be prepared to have the other corresponding datasource and delegate methods to be called with a 'nil' tableColumn value. If don't return a cell, the method will be called once for each tableColumn in the tableView, as usual.
*/
/*
- (NSCell *)tableView:(NSTableView *)tableView dataCellForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_234#>
}
*/
/* Optional - Group rows. 
    Implement this method and return YES to indicate a particular row should have the \"group row\" style drawn for that row. If the cell in that row is an NSTextFieldCell and contains only a stringValue, the \"group row\" style attributes will automatically be applied for that cell. Group rows are drawn differently depending on the selectionHighlightStyle. For NSTableViewSelectionHighlightStyleRegular, there is a blue gradient background. For NSTableViewSelectionHighlightStyleSourceList, the text is light blue, and there is no background.
*/
/*
- (BOOL)tableView:(NSTableView *)tableView isGroupRow:(NSInteger)row AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER
{
	// optional method
	<#statements_235#>
}
*/
/* Optional - Autosizing table columns
 Implement this method if you want to control how wide a column is made when the user double clicks on the resize divider. By default, NSTableView iterates every row in the table, accesses a cell via preparedCellAtRow:column:, and requests the \"cellSize\" to find the appropriate largest width to use. For large row counts, a monte carlo simulation is done instead of interating every row. For performance and accurate results, it is recommended that this method is implemented when using large tables.
 */
/*
- (CGFloat)tableView:(NSTableView *)tableView sizeToFitWidthOfColumn:(NSInteger)column AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_236#>
}
*/
/*  Optional - Control of column reordering.
 Specifies if the column can be reordered to a new location, or not. 'columnIndex' is the column that is being dragged. The actual NSTableColumn instance can be retrieved from the [tableView tableColumns] array. 'newColumnIndex' is the new proposed target location for 'columnIndex'. When a column is initially dragged by the user, the delegate is first called with a 'newColumnIndex' of -1. Returning NO will disallow that column from being reordered at all. Returning YES allows it to be reordered, and the delegate will be called again when the column reaches a new location. If this method is not implemented, all columns are considered reorderable. 
 */
/*
- (BOOL)tableView:(NSTableView *)tableView shouldReorderColumn:(NSInteger)columnIndex toColumn:(NSInteger)newColumnIndex AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_237#>
}
*/
/*  Notifications
 */
/*
- (void)tableViewSelectionDidChange:(NSNotification *)notification
{
	// optional method
	<#statements_238#>
}
*/
/*
- (void)tableViewColumnDidMove:(NSNotification *)notification
{
	// optional method
	<#statements_239#>
}
*/
/*
- (void)tableViewColumnDidResize:(NSNotification *)notification
{
	// optional method
	<#statements_240#>
}
*/
/*
- (void)tableViewSelectionIsChanging:(NSNotification *)notification
{
	// optional method
	<#statements_241#>
}
*/
";
	},

	// 
	// Protocol NSTableViewDataSource
	// 
	{
		Identifier = objc.protocols10_6.NSTableViewDataSource;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSTableViewDataSource implementation (MacOSX 10.6)";
		CompletionPrefix = "NSTableViewDataSource";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSTableViewDataSource implementation
//

/* Required Methods
*/
/*
- (NSInteger)numberOfRowsInTableView:(NSTableView *)tableView
{
	// optional method
	<#statements_242#>
}
*/
/*
- (id)tableView:(NSTableView *)tableView objectValueForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row
{
	// optional method
	<#statements_243#>
}
*/
/* Optional - Editing Support
*/
/*
- (void)tableView:(NSTableView *)tableView setObjectValue:(id)object forTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row
{
	// optional method
	<#statements_244#>
}
*/
/* Optional - sorting support
        This is the indication that sorting needs to be done.  Typically the data source will sort its data, reload, and adjust selections.
*/
/*
- (void)tableView:(NSTableView *)tableView sortDescriptorsDidChange:(NSArray *)oldDescriptors AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
{
	// optional method
	<#statements_245#>
}
*/
/* Optional - Drag and Drop support
    This method is called after it has been determined that a drag should begin, but before the drag has been started.  To refuse the drag, return NO.  To start a drag, return YES and place the drag data onto the pasteboard (data, owner, etc...).  The drag image and other drag related information will be set up and provided by the table view once this call returns with YES.  'rowIndexes' contains the row indexes that will be participating in the drag.

   Compatability Note: This method replaces tableView:writeRows:toPasteboard:.  If present, this is used instead of the deprecated method.
*/
/*
- (BOOL)tableView:(NSTableView *)tableView writeRowsWithIndexes:(NSIndexSet *)rowIndexes toPasteboard:(NSPasteboard *)pboard AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER
{
	// optional method
	<#statements_246#>
}
*/
/* This method is used by NSTableView to determine a valid drop target. Based on the mouse position, the table view will suggest a proposed drop 'row' and 'dropOperation'. This method must return a value that indicates which NSDragOperation the data source will perform. The data source may \"re-target\" a drop, if desired, by calling setDropRow:dropOperation: and returning something other than NSDragOperationNone. One may choose to re-target for various reasons (eg. for better visual feedback when inserting into a sorted position).
*/
/*
- (NSDragOperation)tableView:(NSTableView *)tableView validateDrop:(id <NSDraggingInfo>)info proposedRow:(NSInteger)row proposedDropOperation:(NSTableViewDropOperation)dropOperation
{
	// optional method
	<#statements_247#>
}
*/
/* This method is called when the mouse is released over an outline view that previously decided to allow a drop via the validateDrop method.  The data source should incorporate the data from the dragging pasteboard at this time. 'row' and 'dropOperation' contain the values previously set in the validateDrop: method.
*/
/*
- (BOOL)tableView:(NSTableView *)tableView acceptDrop:(id <NSDraggingInfo>)info row:(NSInteger)row dropOperation:(NSTableViewDropOperation)dropOperation
{
	// optional method
	<#statements_248#>
}
*/
/* NSTableView data source objects can support file promised drags via by adding  NSFilesPromisePboardType to the pasteboard in tableView:writeRowsWithIndexes:toPasteboard:.  NSTableView implements -namesOfPromisedFilesDroppedAtDestination: to return the results of this data source method.  This method should returns an array of filenames for the created files (filenames only, not full paths).  The URL represents the drop location.  For more information on file promise dragging, see documentation on the NSDraggingSource protocol and -namesOfPromisedFilesDroppedAtDestination:.
*/
/*
- (NSArray *)tableView:(NSTableView *)tableView namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropDestination forDraggedRowsWithIndexes:(NSIndexSet *)indexSet AVAILABLE_MAC_OS_X_VERSION_10_4_AND_LATER
{
	// optional method
	<#statements_249#>
}
*/
";
	},

	// 
	// Protocol NSTextAttachmentCell
	// 
	{
		Identifier = objc.protocols10_6.NSTextAttachmentCell;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSTextAttachmentCell implementation (MacOSX 10.6)";
		CompletionPrefix = "NSTextAttachmentCell";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSTextAttachmentCell implementation
//

- (void)drawWithFrame:(NSRect)cellFrame inView:(NSView *)controlView
{
	// required method
	<#statements_250#>
}
- (BOOL)wantsToTrackMouse
{
	// required method
	<#statements_251#>
}
- (void)highlight:(BOOL)flag withFrame:(NSRect)cellFrame inView:(NSView *)controlView
{
	// required method
	<#statements_252#>
}
- (BOOL)trackMouse:(NSEvent *)theEvent inRect:(NSRect)cellFrame ofView:(NSView *)controlView untilMouseUp:(BOOL)flag
{
	// required method
	<#statements_253#>
}
- (NSSize)cellSize
{
	// required method
	<#statements_254#>
}
- (NSPoint)cellBaselineOffset
{
	// required method
	<#statements_255#>
}
- (void)setAttachment:(NSTextAttachment *)anObject
{
	// required method
	<#statements_256#>
}
- (NSTextAttachment *)attachment
{
	// required method
	<#statements_257#>
}
- (void)drawWithFrame:(NSRect)cellFrame inView:(NSView *)controlView characterIndex:(NSUInteger)charIndex
{
	// required method
	<#statements_258#>
}
- (void)drawWithFrame:(NSRect)cellFrame inView:(NSView *)controlView characterIndex:(NSUInteger)charIndex layoutManager:(NSLayoutManager *)layoutManager
{
	// required method
	<#statements_259#>
}
- (BOOL)wantsToTrackMouseForEvent:(NSEvent *)theEvent inRect:(NSRect)cellFrame ofView:(NSView *)controlView atCharacterIndex:(NSUInteger)charIndex
{
	// required method
	<#statements_260#>
}
- (BOOL)trackMouse:(NSEvent *)theEvent inRect:(NSRect)cellFrame ofView:(NSView *)controlView atCharacterIndex:(NSUInteger)charIndex untilMouseUp:(BOOL)flag
{
	// required method
	<#statements_261#>
}
- (NSRect)cellFrameForTextContainer:(NSTextContainer *)textContainer proposedLineFragment:(NSRect)lineFrag glyphPosition:(NSPoint)position characterIndex:(NSUInteger)charIndex
{
	// required method
	<#statements_262#>
}
";
	},

	// 
	// Protocol NSTextInputClient
	// 
	{
		Identifier = objc.protocols10_6.NSTextInputClient;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSTextInputClient implementation (MacOSX 10.6)";
		CompletionPrefix = "NSTextInputClient";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSTextInputClient implementation
//

/* The receiver inserts aString replacing the content specified by replacementRange. aString can be either an NSString or NSAttributedString instance.
*/
- (void)insertText:(id)aString replacementRange:(NSRange)replacementRange
{
	// required method
	<#statements_263#>
}
/* The receiver invokes the action specified by aSelector.
*/
 - (void)doCommandBySelector:(SEL)aSelector
{
	// required method
	<#statements_264#>
}
/* The receiver inserts aString replacing the content specified by replacementRange. aString can be either an NSString or NSAttributedString instance. selectedRange specifies the selection inside the string being inserted; hence, the location is relative to the beginning of aString. When aString is an NSString, the receiver is expected to render the marked text with distinguishing appearance (i.e. NSTextView renders with -markedTextAttributes).
*/
- (void)setMarkedText:(id)aString selectedRange:(NSRange)selectedRange replacementRange:(NSRange)replacementRange
{
	// required method
	<#statements_265#>
}
/* The receiver unmarks the marked text. If no marked text, the invocation of this method has no effect.
*/
- (void)unmarkText
{
	// required method
	<#statements_266#>
}
/* Returns the selection range. The valid location is from 0 to the document length.
*/
- (NSRange)selectedRange
{
	// required method
	<#statements_267#>
}
/* Returns the marked range. Returns {NSNotFound, 0} if no marked range.
*/
- (NSRange)markedRange
{
	// required method
	<#statements_268#>
}
/* Returns whether or not the receiver has marked text.
*/
- (BOOL)hasMarkedText
{
	// required method
	<#statements_269#>
}
/* Returns attributed string specified by aRange. It may return nil. If non-nil return value and actualRange is non-NULL, it contains the actual range for the return value. The range can be adjusted from various reasons (i.e. adjust to grapheme cluster boundary, performance optimization, etc).
*/
- (NSAttributedString *)attributedSubstringForProposedRange:(NSRange)aRange actualRange:(NSRangePointer)actualRange
{
	// required method
	<#statements_270#>
}
/* Returns an array of attribute names recognized by the receiver.
*/
- (NSArray*)validAttributesForMarkedText
{
	// required method
	<#statements_271#>
}
/* Returns the first logical rectangular area for aRange. The return value is in the screen coordinate. The size value can be negative if the text flows to the left. If non-NULL, actuallRange contains the character range corresponding to the returned area.
*/
- (NSRect)firstRectForCharacterRange:(NSRange)aRange actualRange:(NSRangePointer)actualRange
{
	// required method
	<#statements_272#>
}
/* Returns the index for character that is nearest to aPoint. aPoint is in the screen coordinate system.
*/
- (NSUInteger)characterIndexForPoint:(NSPoint)aPoint
{
	// required method
	<#statements_273#>
}
/* Returns an attributed string representing the receiver's document content. An NSTextInputClient can implement this interface if can be done efficiently. The caller of this interface can random access arbitrary portions of the receiver's content more efficiently.
*/
/*
- (NSAttributedString *)attributedString
{
	// optional method
	<#statements_274#>
}
*/
/* Returns the fraction of distance for aPoint from the left side of the character. This allows caller to perform precise selection handling.
*/
/*
- (CGFloat)fractionOfDistanceThroughGlyphForPoint:(NSPoint)aPoint
{
	// optional method
	<#statements_275#>
}
*/
/* Returns the baseline position relative to the origin of rectangle returned by -firstRectForCharacterRange:actualRange:. This information allows the caller to access finer-grained character position inside the NSTextInputClient document.
*/
/*
- (CGFloat)baselineDeltaForCharacterAtIndex:(NSUInteger)anIndex
{
	// optional method
	<#statements_276#>
}
*/
/* Returns the window level of the receiver. An NSTextInputClient can implement this interface to specify its window level if it is higher than NSFloatingWindowLevel.
*/
/*
- (NSInteger)windowLevel
{
	// optional method
	<#statements_277#>
}
*/
/* Returns if the marked text is in vertical layout.
 */
/*
- (BOOL)drawsVerticallyForCharacterAtIndex:(NSUInteger)charIndex AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_278#>
}
*/
";
	},

	// 
	// Protocol NSTokenFieldDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSTokenFieldDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSTokenFieldDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSTokenFieldDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSTokenFieldDelegate implementation
//

/*
- (NSArray *)tokenField:(NSTokenField *)tokenField completionsForSubstring:(NSString *)substring indexOfToken:(NSInteger)tokenIndex indexOfSelectedItem:(NSInteger *)selectedIndex
{
	// optional method
	<#statements_279#>
}
*/
/*
- (NSArray *)tokenField:(NSTokenField *)tokenField shouldAddObjects:(NSArray *)tokens atIndex:(NSUInteger)index
{
	// optional method
	<#statements_280#>
}
*/
/*
- (NSString *)tokenField:(NSTokenField *)tokenField displayStringForRepresentedObject:(id)representedObject
{
	// optional method
	<#statements_281#>
}
*/
/*
- (NSString *)tokenField:(NSTokenField *)tokenField editingStringForRepresentedObject:(id)representedObject
{
	// optional method
	<#statements_282#>
}
*/
/*
- (id)tokenField:(NSTokenField *)tokenField representedObjectForEditingString: (NSString *)editingString
{
	// optional method
	<#statements_283#>
}
*/
/*
- (BOOL)tokenField:(NSTokenField *)tokenField writeRepresentedObjects:(NSArray *)objects toPasteboard:(NSPasteboard *)pboard
{
	// optional method
	<#statements_284#>
}
*/
/*
- (NSArray *)tokenField:(NSTokenField *)tokenField readFromPasteboard:(NSPasteboard *)pboard
{
	// optional method
	<#statements_285#>
}
*/
/*
- (NSMenu *)tokenField:(NSTokenField *)tokenField menuForRepresentedObject:(id)representedObject
{
	// optional method
	<#statements_286#>
}
*/
/*
- (BOOL)tokenField:(NSTokenField *)tokenField hasMenuForRepresentedObject:(id)representedObject
{
	// optional method
	<#statements_287#>
}
*/
/*
- (NSTokenStyle)tokenField:(NSTokenField *)tokenField styleForRepresentedObject:(id)representedObject
{
	// optional method
	<#statements_288#>
}
*/
";
	},

	// 
	// Protocol NSTokenFieldCellDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSTokenFieldCellDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSTokenFieldCellDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSTokenFieldCellDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSTokenFieldCellDelegate implementation
//

/*
- (NSArray *)tokenFieldCell:(NSTokenFieldCell *)tokenFieldCell completionsForSubstring:(NSString *)substring indexOfToken:(NSInteger)tokenIndex indexOfSelectedItem:(NSInteger *)selectedIndex
{
	// optional method
	<#statements_289#>
}
*/
/*
- (NSArray *)tokenFieldCell:(NSTokenFieldCell *)tokenFieldCell shouldAddObjects:(NSArray *)tokens atIndex:(NSUInteger)index
{
	// optional method
	<#statements_290#>
}
*/
/*
- (NSString *)tokenFieldCell:(NSTokenFieldCell *)tokenFieldCell displayStringForRepresentedObject:(id)representedObject
{
	// optional method
	<#statements_291#>
}
*/
/*
- (NSString *)tokenFieldCell:(NSTokenFieldCell *)tokenFieldCell editingStringForRepresentedObject:(id)representedObject
{
	// optional method
	<#statements_292#>
}
*/
/*
- (id)tokenFieldCell:(NSTokenFieldCell *)tokenFieldCell representedObjectForEditingString: (NSString *)editingString
{
	// optional method
	<#statements_293#>
}
*/
/*
- (BOOL)tokenFieldCell:(NSTokenFieldCell *)tokenFieldCell writeRepresentedObjects:(NSArray *)objects toPasteboard:(NSPasteboard *)pboard
{
	// optional method
	<#statements_294#>
}
*/
/*
- (NSArray *)tokenFieldCell:(NSTokenFieldCell *)tokenFieldCell readFromPasteboard:(NSPasteboard *)pboard
{
	// optional method
	<#statements_295#>
}
*/
/*
- (NSMenu *)tokenFieldCell:(NSTokenFieldCell *)tokenFieldCell menuForRepresentedObject:(id)representedObject
{
	// optional method
	<#statements_296#>
}
*/
/*
- (BOOL)tokenFieldCell:(NSTokenFieldCell *)tokenFieldCell hasMenuForRepresentedObject:(id)representedObject
{
	// optional method
	<#statements_297#>
}
*/
/*
- (NSTokenStyle)tokenFieldCell:(NSTokenFieldCell *)tokenFieldCell styleForRepresentedObject:(id)representedObject
{
	// optional method
	<#statements_298#>
}
*/
";
	},

	// 
	// Protocol NSToolbarDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSToolbarDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSToolbarDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSToolbarDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSToolbarDelegate implementation
//

/*The following three methods are required for toolbars that are not created in Interface Builder.  If the toolbar is created in IB, you may omit them.  If you do implement them, any  items returned by the delegate will be used alongside items created in Interface Builder. */
/*
- (NSToolbarItem *)toolbar:(NSToolbar *)toolbar itemForItemIdentifier:(NSString *)itemIdentifier willBeInsertedIntoToolbar:(BOOL)flag
{
	// optional method
	<#statements_299#>
}
*/
    /* Given an item identifier, this method returns an item.  Note that, it is expected that each toolbar receives its own distinct copies.   If the item has a custom view, that view should be in place when the item is returned.  Finally, do not assume the returned item is going to be added as an active item in the toolbar.  In fact, the toolbar may ask for items here in order to construct the customization palette (it makes copies of the returned items).  if willBeInsertedIntoToolbar is YES, the returned item will be inserted, and you can expect toolbarWillAddItem: is about to be posted.  */
/*
- (NSArray *)toolbarDefaultItemIdentifiers:(NSToolbar*)toolbar
{
	// optional method
	<#statements_300#>
}
*/
    /* Returns the ordered list of items to be shown in the toolbar by default.   If during initialization, no overriding values are found in the user defaults, or if the user chooses to revert to the default items this set will be used. */
/*
- (NSArray *)toolbarAllowedItemIdentifiers:(NSToolbar*)toolbar
{
	// optional method
	<#statements_301#>
}
*/
    /* Returns the list of all allowed items by identifier.  By default, the toolbar does not assume any items are allowed, even the separator.  So, every allowed item must be explicitly listed.  The set of allowed items is used to construct the customization palette.  The order of items does not necessarily guarantee the order of appearance in the palette.  At minimum, you should return the default item list.*/
/*
- (NSArray *)toolbarSelectableItemIdentifiers:(NSToolbar *)toolbar
{
	// optional method
	<#statements_302#>
}
*/
    /* Optional method. Those wishing to indicate item selection in a toolbar should implement this method to return a non-empty array of selectable item identifiers.  If implemented, the toolbar will remember and display the selected item with a special highlight.  A selected item is one whose item identifier matches the current selected item identifier.  Clicking on an item whose identifier is selectable will automatically update the toolbars selected item identifier when possible. (see setSelectedItemIdentifier: for more details) */
    /* Notifications */
/*
- (void)toolbarWillAddItem: (NSNotification *)notification
{
	// optional method
	<#statements_303#>
}
*/
    /* Before an new item is added to the toolbar, this notification is posted.  This is the best place to notice a new item is going into the toolbar.  For instance, if you need to cache a reference to the toolbar item or need to set up some initial state, this is the best place to do it.   The notification object is the toolbar to which the item is being added.  The item being added is found by referencing the @\"item\" key in the userInfo.  */
/*
- (void)toolbarDidRemoveItem: (NSNotification *)notification
{
	// optional method
	<#statements_304#>
}
*/
    /* After an item is removed from a toolbar the notification is sent.  This allows the chance to tear down information related to the item that may have been cached.  The notification object is the toolbar from which the item is being removed.  The item being removed is found by referencing the @\"item\" key in the userInfo.  */
";
	},

	// 
	// Protocol NSUserInterfaceItemSearching
	// 
	{
		Identifier = objc.protocols10_6.NSUserInterfaceItemSearching;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSUserInterfaceItemSearching implementation (MacOSX 10.6)";
		CompletionPrefix = "NSUserInterfaceItemSearching";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSUserInterfaceItemSearching implementation
//

/*  Search for items matching the provided search string and return them by calling the matched items block, passing an array of items to append to the help menu.  The framework does not care what these items are. They are just used to identify particular search results to other methods in this protocol.  Do not assume that this will be called from the main UI thread.  When searchForItemsWithSearchString gets called again, the client should cancel any previous searches in progress for better performance.  If not Spotlight for Help will ignore the older results.  resultLimit is the maximum number of results that Spotlight for Help will process.  Any results returned beyond this limit will be ignored, but for performance reasons it is better to not exceed it.

    The handleMatchedItems block can be invoked from any thread desired.  If it is called more than once the additional results will be appended after previous items until the maximum is reached.
 */
- (void)searchForItemsWithSearchString:(NSString *)searchString resultLimit:(NSInteger)resultLimit matchedItemHandler:(void (^)(NSArray *items))handleMatchedItems
{
	// required method
	<#statements_305#>
}
/* return an array of strings (localized for display in the menu) that will be combined with separators to form the menu item title
 */
- (NSArray *)localizedTitlesForItem:(id)item
{
	// required method
	<#statements_306#>
}
/* Called when the user selects a search result in Help menu. For example, the default implementation brings up Help Viewer for a Help item. 
 */
/*
- (void)performActionForItem:(id)item
{
	// optional method
	<#statements_307#>
}
*/
/* If this method is implemented, a \"Show All Help Topics\" item will appear in the menu and this method is called when the user selects it.  The application should show all its results for this search, which does not include results for Menu Items.  The string for \"Show All Help Topics\" is system defined and localized and cannot be changed by the user.
 */
/*
- (void)showAllHelpTopicsForSearchString:(NSString *)searchString
{
	// optional method
	<#statements_308#>
}
*/
";
	},

	// 
	// Protocol NSUserInterfaceValidations
	// 
	{
		Identifier = objc.protocols10_6.NSUserInterfaceValidations;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSUserInterfaceValidations implementation (MacOSX 10.6)";
		CompletionPrefix = "NSUserInterfaceValidations";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSUserInterfaceValidations implementation
//

- (BOOL)validateUserInterfaceItem:(id <NSValidatedUserInterfaceItem>)anItem
{
	// required method
	<#statements_309#>
}
";
	},

	// 
	// Protocol NSWindowDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSWindowDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSWindowDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSWindowDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSWindowDelegate implementation
//

/*
- (BOOL)windowShouldClose:(id)sender
{
	// optional method
	<#statements_310#>
}
*/
/*
- (id)windowWillReturnFieldEditor:(NSWindow *)sender toObject:(id)client
{
	// optional method
	<#statements_311#>
}
*/
/*
- (NSSize)windowWillResize:(NSWindow *)sender toSize:(NSSize)frameSize
{
	// optional method
	<#statements_312#>
}
*/
/*
- (NSRect)windowWillUseStandardFrame:(NSWindow *)window defaultFrame:(NSRect)newFrame
{
	// optional method
	<#statements_313#>
}
*/
/*
- (BOOL)windowShouldZoom:(NSWindow *)window toFrame:(NSRect)newFrame
{
	// optional method
	<#statements_314#>
}
*/
/*
- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window
{
	// optional method
	<#statements_315#>
}
*/
/*
- (NSRect)window:(NSWindow *)window willPositionSheet:(NSWindow *)sheet usingRect:(NSRect)rect
{
	// optional method
	<#statements_316#>
}
*/
/* If a window has a representedURL, the window will by default show a path popup menu for a command-click on a rectangle containing the window document icon button and the window title.  The window delegate may implement -window:shouldPopupDocumentPathMenu: to override NSWindow's default behavior for path popup menu.  A return of NO will prevent the menu from being shown.  A return of YES will cause the window to show the menu passed to this method, which by default will contain a menuItem for each path component of the representedURL.  If the representedURL has no path components, the menu will have no menu items.  Before returning YES, the window delegate may customize the menu by changing the menuItems.  menuItems may be added or deleted, and each menuItem title, action, or target may be modified. 
*/
/*
- (BOOL)window:(NSWindow *)window shouldPopUpDocumentPathMenu:(NSMenu *)menu
{
	// optional method
	<#statements_317#>
}
*/
/* The window delegate may implement -window:shouldDragDocumentWithEvent:from:withPasteboard: to override NSWindow document icon's default drag behavior.  The delegate can prohibit the drag by returning NO.  Before returning NO, the delegate may implement its own dragging behavior using -[NSWindow dragImage:at:offset:event:pasteboard:source:slideBack:].  Alternatively, the delegate can enable a drag by returning YES, for example to override NSWindow's default behavior of prohibiting the drag of an edited document.  Lastly, the delegate can customize the pasteboard contents before returning YES.
*/
/*
- (BOOL)window:(NSWindow *)window shouldDragDocumentWithEvent:(NSEvent *)event from:(NSPoint)dragImageLocation withPasteboard:(NSPasteboard *)pasteboard
{
	// optional method
	<#statements_318#>
}
*/
/* Notifications
*/
/*
- (void)windowDidResize:(NSNotification *)notification
{
	// optional method
	<#statements_319#>
}
*/
/*
- (void)windowDidExpose:(NSNotification *)notification
{
	// optional method
	<#statements_320#>
}
*/
/*
- (void)windowWillMove:(NSNotification *)notification
{
	// optional method
	<#statements_321#>
}
*/
/*
- (void)windowDidMove:(NSNotification *)notification
{
	// optional method
	<#statements_322#>
}
*/
/*
- (void)windowDidBecomeKey:(NSNotification *)notification
{
	// optional method
	<#statements_323#>
}
*/
/*
- (void)windowDidResignKey:(NSNotification *)notification
{
	// optional method
	<#statements_324#>
}
*/
/*
- (void)windowDidBecomeMain:(NSNotification *)notification
{
	// optional method
	<#statements_325#>
}
*/
/*
- (void)windowDidResignMain:(NSNotification *)notification
{
	// optional method
	<#statements_326#>
}
*/
/*
- (void)windowWillClose:(NSNotification *)notification
{
	// optional method
	<#statements_327#>
}
*/
/*
- (void)windowWillMiniaturize:(NSNotification *)notification
{
	// optional method
	<#statements_328#>
}
*/
/*
- (void)windowDidMiniaturize:(NSNotification *)notification
{
	// optional method
	<#statements_329#>
}
*/
/*
- (void)windowDidDeminiaturize:(NSNotification *)notification
{
	// optional method
	<#statements_330#>
}
*/
/*
- (void)windowDidUpdate:(NSNotification *)notification
{
	// optional method
	<#statements_331#>
}
*/
/*
- (void)windowDidChangeScreen:(NSNotification *)notification
{
	// optional method
	<#statements_332#>
}
*/
/*
- (void)windowDidChangeScreenProfile:(NSNotification *)notification
{
	// optional method
	<#statements_333#>
}
*/
/*
- (void)windowWillBeginSheet:(NSNotification *)notification
{
	// optional method
	<#statements_334#>
}
*/
/*
- (void)windowDidEndSheet:(NSNotification *)notification
{
	// optional method
	<#statements_335#>
}
*/
/*
- (void)windowWillStartLiveResize:(NSNotification *)notification    AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_336#>
}
*/
/*
- (void)windowDidEndLiveResize:(NSNotification *)notification   AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER
{
	// optional method
	<#statements_337#>
}
*/
";
	},

	// 
	// Protocol AUCocoaUIBase
	// 
	{
		Identifier = objc.protocols10_6.AUCocoaUIBase;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "AUCocoaUIBase implementation (MacOSX 10.6)";
		CompletionPrefix = "AUCocoaUIBase";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: AUCocoaUIBase implementation
//

/*!
	@header AUCocoaUIView
	This file specifies a protocol that cocoa-based audio unit views will implement. Audio Unit hosts will call these methods to retrieve the view for your audio unit.
 */
/*!
	@function	interfaceVersion
	@abstract	Return the version of the interface you are implementing.
	@result		An unsigned value.
	@discussion For MacOS X 10.3 or later, you should return the current version which is 0.
				NOTE: Developers are strongly encouraged to override -(NSString *)description to return the name
				of the cocoa view. This name is displayed by host applications and should be returned as a copy
				instead of a static string.
				
				For example, you could define the description method like this:
					- (NSString *) description {
						return [NSString withString: @\"Filter View\"];
					}
*/
- (unsigned)interfaceVersion
{
	// required method
	<#statements_338#>
}
/*!
	@function	uiViewForAudioUnit:withSize:
	@abstract	Return the NSView responsible for displaying the interface for the provided AudioUnit.
	@param		inAudioUnit
					The Audio Unit the view is associated with.
	@param		inPreferredSize
					The preferred size of the view to be returned.
	@result		An NSView.
	
	@discussion
				This method is a factory function: each call to it must return a unique view.
				Each view must be returned with a retain count of 1 and autoreleased.
				It is the client's responsibility to retain the returned view and to release the view when it's no longer needed.
*/
- (NSView *)uiViewForAudioUnit:(AudioUnit)inAudioUnit withSize:(NSSize)inPreferredSize
{
	// required method
	<#statements_339#>
}
";
	},

	// 
	// Protocol IMKTextInput
	// 
	{
		Identifier = objc.protocols10_6.IMKTextInput;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IMKTextInput implementation (MacOSX 10.6)";
		CompletionPrefix = "IMKTextInput";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IMKTextInput implementation
//

/*!
    @method     
    @abstract   Sends text that has been fully converted to an input session.
    @discussion When an input method finishes a conversion it calls this method and passes the finished text as an NSString or NSAttributedString. The replacementRange parameter is there to allow input methods to insert text at a location other than the current selection.
               
               If used the replacementRange should be relative to the beginning of the client document.
               
               If the string should be inserted at the current selection specify a replacementRange with a location and length of NSNotFound.

                If the client does not support the TSMDocumentAccess protocol the replacementRange string will be ignored.
*/
- (void)insertText:(id)string replacementRange:(NSRange)replacementRange
{
	// required method
	<#statements_340#>
}
/*!
    @method     
    @abstract   Insert the text and mark it to indicate that it is part of an active input session. 
    @discussion The string parameter must be an NSString or an NSAttributedString. Passing an NSString will produce default marking ( On a 72 dpi screen that is a 2 pixel black underline for the entire string).  SelectionRange indicates the area of the string that should be selected and therefore if possible the area that should be displayed. SelectionRange is relative to the string parameter.
                
               For example, if the string contains the these characters: \"INPUT\" and the range is (5,0) the selection will be set right after the \"T.\"
                
               ReplacementRange specifies the location in the client document where the marked text should be placed.  If the marked text should be placed at the current cursor location replacementRange.location will equal NSNotFound.  If used (i.e. location is not NSNotFound) the replacementRange is relative to the client document (i.e. 0 is the beginning of the document) and NOT the string parameter.
             
               Currently, the replacement range is sent to the client via the kEventParamTextInputSendReplaceRange Carbon Event parameter.  As noted in the comment for this parameter for this parameter to be used the client must support the TSMDocumentAccess protocol.  If a client does not support the TSMDocumentAccess protocol the replacementRange will be ignored.
*/
- (void)setMarkedText:(id)string selectionRange:(NSRange)selectionRange replacementRange:(NSRange)replacementRange
{
	// required method
	<#statements_341#>
}
/*
    A Note on selectedRange:, attributedSubStringFromRange,  and length.
   
   These methods all depend on the client application supporting  TSMDocumentAccess Carbon events.  Many applications do not support these so input methods should be prepared for these methods to return nil or NSNotFound.  The return that can be expected is included in the  discussion of each of these methods.


*/
/*!
    @method     
    @abstract   Returns the current selection range.
                
   @discussion If the client does not support the TSMDocumentAccess protocol the returned range will have a location value of NSNotFound and a length of NSNotFound.
              
               If a valid range is returned it is relative to the client's document.
*/
- (NSRange)selectedRange
{
	// required method
	<#statements_342#>
}
/*!
    @method    
    @abstract   Returns the range in the document that is occupied by marked text, which in other terms is the current inline session.
    @discussion While an input method is converting text input and sending it to the client the client will maintain a range of text that is marked.  That is to say that there will be a range of text that is underlined in certain ways to indicate to the user that their keystrokes are in the process of being converted by an input method and the conversion has not yet been finalized.  The input method uses this method to request that range.  The returned range is relative to the clients document.  
    
             If this range is not available the range location and length will be NSNotFound.
*/
- (NSRange)markedRange
{
	// required method
	<#statements_343#>
}
/*!
    @method     
    @abstract   Called to request a string along with its attributes such as font and glyph info.
    @discussion Input methods call this method to obtain a range of text from the client document along with that text's font and glyphInfo.  The kind of attributes that can be included in the string are defined in CTStringAttributes.h.  The range should be document relative.
                                
               If the client does not support TSMDocumentAccess the returned string will be created from data obtained by sending the client application a kEventTextInputGetSelectedText Carbon event.

				The returned NSAttributedString is an autoreleased object.  Do not release this object unless you retain it first.
				
				Note it is possible that the returned string will be longer or shorter than the specified range.  This can be caused when there surrogate unicodes in a document, and the range's location or length splits a surrogate pair.
				You can test for this by comparing the string's length against the range you included as the range parameter.
*/
- (NSAttributedString*)attributedSubstringFromRange:(NSRange)range
{
	// required method
	<#statements_344#>
}
/*!
    @method     
    @abstract   Returns the length of the text document.
 @discussion If the client does not support the TSMDocumentAccess protocol the returned value will be NSNotFound.
   
               Please note that depending on how clients store text determing how long a text document is can  be a very expensive operation. Input methods should be aware of this problem and avoid frequently calling this method.
*/
- (NSInteger)length
{
	// required method
	<#statements_345#>
}
/*!
    @method     
    @abstract   Map a global point to a location in the text document.
    @discussion Given a global point (typically from a mousedown) map that to a location in a text document.  
 
               MappingMode is set to kIMKMouseTrackingMode if the input method is tracking the mouse. If the input method is tracking the mouse the application should pin highlighting to the active inline area.  If the input method simply wants to map a screen postion to an offset than mappingMode should be set to kIMKNearestBoundaryMode.
                
               If the point is not inside the text body the returned value will be NSNotFound.  If the point is inside the text body and inside the marked range inMarkedRange will be set to YES.  If it is outside the markedRange it will be set to NO.
*/
- (NSInteger)characterIndexForPoint:(NSPoint)point tracking:(IMKLocationToOffsetMappingMode)mappingMode inMarkedRange:(BOOL*)inMarkedRange
{
	// required method
	<#statements_346#>
}
/*!
    @method     - (NSDictionary*)attributesForCharacterIndex:(NSUInteger)index lineHeightRectangle:(NSRect*)lineRect;
    @abstract   Returns a dictionary of text attributes for the text at a given character index. The attributes include the CTFontRef for the text at that index and the text orientation.  The text orientation is indicated by an NSNumber whose value is 0 if the text is vertically oriented and 1 if the text is horizontally oriented. The key for this value is IMKTextOrientationKey. Additionally, a rectangle that would frame a one-pixel wide rectangle with the height of the line is returned in the frame parameter.  Note that rectangle will be oriented the same way the line is oriented.
    @discussion Input methods will call this method to place a candidate window on the screen. The index is relative to the inline session.  Note that if there is no inline session the value of index should be 0, which indicates that the information should be taken from the current selection.

				The returned NSDictionary is an autoreleased object.  Don't release it unless you have retained it.
    
*/
- (NSDictionary*)attributesForCharacterIndex:(NSUInteger)index lineHeightRectangle:(NSRect*)lineRect
{
	// required method
	<#statements_347#>
}
/*!
    @method     
    @abstract   Returns an array of NSString names for the attributes supported by the receiver. 
   @discussion Input methods should restrict the attributes used to create attributed strings to the attributes in this array.

				This is not a copy function.  The returned NSArray should not be released unless it is first retained.
*/
- (NSArray*)validAttributesForMarkedText
{
	// required method
	<#statements_348#>
}
/*!
    @method     
    @abstract   Override the current keyboard.
    @discussion Pass a keyboard unique name.  The client will try to locate a keyboard layout with that name in the input method's bundle.  If a layout is found it is passed to the client who then tells the text service manager to use that layout for keyboard events.  Input methods should call the method each time they are activated.
               
               If an input method wishes to use a system keyboard to override the current keyboard they are responsible for determining the keyboard's unique name.  Typically this name a DNS type name such as: com.apple.<some name>.
*/
-(void)overrideKeyboardWithKeyboardNamed:(NSString*)keyboardUniqueName
{
	// required method
	<#statements_349#>
}
/*!
    @method     
    @abstract   Select a new  input mode.
    @discussion The mode identifier is an NSString with a DNS format.  
               
               Typically the mode identifier is a DNS type name such as: com.<company name>.inputmethod.<some name>.  The identifier should match one of the keys in the  ComponentInputModeDict.  This method allows an input method to change its mode directly.
*/
-(void)selectInputMode:(NSString*)modeIdentifier
{
	// required method
	<#statements_350#>
}
/*!
    @method     
    @abstract   Test to see if the current input session supports Unicode text.
    @discussion Input methods that restrict the character codes sent to a client if that client does not support Unicode text should call this method to learn if a given input session supports Unicode text.
*/
-(BOOL)supportsUnicode
{
	// required method
	<#statements_351#>
}
/*!
    @method     
    @abstract   Returns the bundle identifier for the process that the input session is attached to.
    @discussion Many input methods need to be able to identify the process that input sessions belong to.  This method provides that service.

				The returned NSString is an autoreleased object.  Call retain to own it.
*/
-(NSString*)bundleIdentifier
{
	// required method
	<#statements_352#>
}
/*!
    @method     
    @abstract  Returns the window level for client window.
    @discussion Call this to determine the client's window level.  
    
    Internally, IMKCandidates uses this method to determine the correct level for candidate display.  Therefore, input methods that use IMKCandidates have no reason to call this method.  
    
    However, many input method developers have built there own candidate display system, and this method is here for their use.  In order to display a candidate window at the correct level use this method to obtain the client window level, increment the returned level, and then apply that level to any candidate windows.
*/
-(CGWindowLevel)windowLevel
{
	// required method
	<#statements_353#>
}
/*!
    @method     
    @abstract   Check if the current client input session supports a given TSM property.
    @discussion This method is available to provide compatibilty for input methods that need to check TSMDocument properties.
*/
-(BOOL)supportsProperty:(TSMDocumentPropertyTag)property
{
	// required method
	<#statements_354#>
}
";
	},

	// 
	// Protocol IMKUnicodeTextInput
	// 
	{
		Identifier = objc.protocols10_6.IMKUnicodeTextInput;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IMKUnicodeTextInput implementation (MacOSX 10.6)";
		CompletionPrefix = "IMKUnicodeTextInput";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IMKUnicodeTextInput implementation
//

/*!
    @method     
    @abstract   Sends unicode text to the client application.
    @discussion Use this method to send text that was not generated by user keyboard input.  This method should be used by palette input methods that send text to a client.  Typically the text is generated in response to user activity in the palette window. The string parameter can be either an NSString or an NSAttributedString.  Use an NSAttributed string if you need to include NSGlyphInfo objects with the text in the string. 
*/
-(void)insertText:(id)string
{
	// required method
	<#statements_355#>
}
";
	},

	// 
	// Protocol AUCustomViewPersistentData
	// 
	{
		Identifier = objc.protocols10_6.AUCustomViewPersistentData;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "AUCustomViewPersistentData implementation (MacOSX 10.6)";
		CompletionPrefix = "AUCustomViewPersistentData";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: AUCustomViewPersistentData implementation
//

/*!
	@header AUCustomViewPersistentData
	This file specifies a protocol that cocoa-based audio unit views will implement. Audio Unit hosts will call these methods to manage view data that needs to be preserved between subsequent openings of an audio unit's custom view. The view data is an opaque dictionary and can contain any information that the view needs to preserve such as user selection, and interface state such as selected tab view items, etc.

	The host should retrieve the customViewData before closing the view. This can be saved as part of a document, or used to restore view settings by calling setCustomViewData prior to opening the view.
 */
/*!
	@function	customViewPersistentData
	@abstract	Return the custom data to be preserved by the host before closing the view.
	@result		A NSDictionary
	@discussion 	The host should call this method before closing the view. This dictionary should be returned autoreleased.
*/
- (NSDictionary *)customViewPersistentData
{
	// required method
	<#statements_356#>
}
/*!
	@function	setCustomViewPersistentData:
	@abstract	Return the custom data to be preserved by the host between openings of the view.
	@param		A NSDictionary containing the view data to restore when the view is opened.
	@discussion 	This call should be made prior to opening the view. The au view should be written in such a way that it can store this
			dictionary and use its information when the view is opened and user interface elements are created. The view should retain
			this dictionary until it is finished with it, and should not release the dictionary. This dictionary is owned by the host.
*/
- (void) setCustomViewPersistentData:(NSDictionary *) data
{
	// required method
	<#statements_357#>
}
";
	},

	// 
	// Protocol CLLocationManagerDelegate
	// 
	{
		Identifier = objc.protocols10_6.CLLocationManagerDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "CLLocationManagerDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "CLLocationManagerDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: CLLocationManagerDelegate implementation
//

/*
 *  locationManager:didUpdateToLocation:fromLocation:
 *  
 *  Discussion:
 *    Invoked when a new location is available. oldLocation may be nil if there is no previous location
 *    available.
 */
/*
- (void)locationManager:(CLLocationManager *)manager
	didUpdateToLocation:(CLLocation *)newLocation
	fromLocation:(CLLocation *)oldLocation
{
	// optional method
	<#statements_358#>
}
*/
/*
 *  locationManager:didFailWithError:
 *  
 *  Discussion:
 *    Invoked when an error has occurred.
 */
/*
- (void)locationManager:(CLLocationManager *)manager
	didFailWithError:(NSError *)error
{
	// optional method
	<#statements_359#>
}
*/
";
	},

	// 
	// Protocol DRFileDataProduction
	// 
	{
		Identifier = objc.protocols10_6.DRFileDataProduction;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "DRFileDataProduction implementation (MacOSX 10.6)";
		CompletionPrefix = "DRFileDataProduction";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: DRFileDataProduction implementation
//

/*! 
   	@method 		calculateSizeOfFile:fork:estimating:
   	@abstract		Calculates the size of the specified fork of a file.
   	@discussion		This method may be sent at any time after the file object has been instantiated. 
					Requests that the recevier calculate the byte size of a file's fork (for instance, data fork or resource fork).

					If estimate is <i>YES</i>, you are being asked for an estimate of the final 
					fork size, perhaps to provide an estimate of the track size, and do not 
					have to be exact.  Estimates should err on the high side; it's better to 
					overestimate than underestimate. An estimate call may be made at any time.

					If estimate is <i>NO</i>, you are being asked for
					the actual fork size, to be used in the burn.  This call is only
					made in the burn phase.
   	@param 			file	The file object.
   	@param 			fork	The fork of the file whose size is to be calculated.
   	@param			estimate	If the file size should be estimated or exact.
    @result  		The length of the file's fork.
*/
- (uint64_t) calculateSizeOfFile:(DRFile*)file fork:(DRFileFork)fork estimating:(BOOL)estimate
{
	// required method
	<#statements_360#>
}
/*! 
   	@method 		prepareFileForBurn:
   	@abstract		Prepare the file object for burning.
   	@discussion		Sent to the recevier before the burn begins. This would be an appropriate 
					method to open files, or do any other prep work needed.  The disc's entire 
					hierarchy is completely in place and can be queried if needed. 
									
					After this call, the burn's content is locked down, and you should be
					able to respond to the @link //apple_ref/occ/intfm/DRFileDataProduction/calculateSizeOfFile:fork:estimating: calculateSizeOfFile:fork:estimating: @/link messages with exact values.
   	@param 			file	The file object.
    @result  		<i>YES</i> if the burn should proceed.
*/
- (BOOL) prepareFileForBurn:(DRFile*)file
{
	// required method
	<#statements_361#>
}
/*! 
   	@method 		produceFile:fork:intoBuffer:length:atAddress:blockSize:
   	@abstract		Produces the specified fork contents for burning.
   	@discussion		Sent during the burn (after the @link //apple_ref/occ/intfm/DRFileDataProduction/prepareFileForBurn prepareFileForBurn @/link message) requesting that the receiver
					produce the specified fork contents. 
									
					The recevier should fill up the buffer passed in as full as possible 
					and then return control to the caller. While burning keeping the drive's buffer full is 
					of utmost importance, so you should not perform lengthy operations or block for data in this method.
					This method should return the number of bytes actually in the buffer or 0 to indicate that there
					was an error producing the data.
					
					You may be asked to produce twice, once during the actual burn and once during 
					verification depending on the verification type of the track.
   	@param 			file	The file object.
   	@param 			fork	The fork of the file to produce.
   	@param			buffer	The buffer to produce data into.
   	@param			bufferLength	The length of the buffer to produce data into
   	@param			address	The byte address in the file that the burn engine is requesting
   	@param			blockSize	The size of the track blocks
	@result			The number of bytes produced.
*/
- (uint32_t) produceFile:(DRFile*)file fork:(DRFileFork)fork intoBuffer:(char*)buffer length:(uint32_t)bufferLength atAddress:(uint64_t)address blockSize:(uint32_t)blockSize
{
	// required method
	<#statements_362#>
}
/*! 
   	@method 		prepareFileForVerification:
   	@abstract		Prepare the file object for verification.
   	@discussion		Sent during the burn (after production and before the @link //apple_ref/occ/intfm/DRFileDataProduction/cleanupFileAfterBurn: cleanupFileAfterBurn: @/link message) to 
   					indicate that verification is about to begin. Now would be a good
					time to rewind to the start of the file, reset state machines, or do whatever else 
					is needed to prepare to produce again.
   	@param 			file	The file object.
	@result			<i>YES</i> to indicate that the verification should proceed and <i>NO</i> to indicate a failure occurred.
*/
- (BOOL) prepareFileForVerification:(DRFile*)file
{
	// required method
	<#statements_363#>
}
/*! 
   	@method 		cleanupFileAfterBurn:
   	@abstract		Cleanup the file object once the burn is complete.
   	@discussion		Sent to the receiver after the burn completes. This would be an appropriate 
					place to close files, or do any other teardown work needed.  This message will 
					always be sent regardless of whether the burn succeeded or failed
   	@param 			file	The file object.
*/
- (void) cleanupFileAfterBurn:(DRFile*)file
{
	// required method
	<#statements_364#>
}
";
	},

	// 
	// Protocol DRTrackDataProduction
	// 
	{
		Identifier = objc.protocols10_6.DRTrackDataProduction;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "DRTrackDataProduction implementation (MacOSX 10.6)";
		CompletionPrefix = "DRTrackDataProduction";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: DRTrackDataProduction implementation
//

/*!
	@method			estimateLengthOfTrack:
	@abstract		Estimates the size of the track to be burned.
	@discussion		This message is sent outside of a burn cycle in response to a -estimateLength message 
					sent to the track.
					
					
	@param			track	The track object for which to estimate the size
	@result			The number of blocks of data that the track will occupy. The estimate should be 
					reasonably accurate, and no smaller than the actual size that will be needed.
*/
- (uint64_t) estimateLengthOfTrack:(DRTrack*)track
{
	// required method
	<#statements_365#>
}
/*!
	@method			prepareTrack:forBurn:toMedia:
	@abstract		Prepares the track for burning.
	@discussion		Called before any burning starts. Do any sort of setup that needs to be performed
					(such as opening files). This method can calculate and update the exact track length
					that will be burned.
					
					Since this method is called before the laser is turned on, this method can perform 
					time consuming tasks. 
	@param			track	The track object being burned
	@param			burn	The burn object controlling the burn
	@param			mediaInfo	The media being burned to. This is the same dictionary as returned by @link //apple_ref/occ/instm/DRDevice/status -[DRDevice status] @/link.
	@result			<i>YES</i> to indicate that the burn should proceed and <i>NO</i> to indicate a failure occurred.
*/
- (BOOL) prepareTrack:(DRTrack*)track forBurn:(DRBurn*)burn toMedia:(NSDictionary*)mediaInfo
{
	// required method
	<#statements_366#>
}
/*!
	@method			cleanupTrackAfterBurn:
	@abstract		Cleans up the track after the burn completes.
	@discussion		Called after burning is complete. Typically you'll clean up what was setup in <b>prepareTrackForBurn</b>. 
					Since this method is called after the laser is turned off and the burn is finished, 
					this method can perform time consuming tasks. 
	@param			track	The track object being burned
	@result			<i>YES</i> to indicate that the burn should proceed and <i>NO</i> to indicate a failure occurred.
*/
- (void) cleanupTrackAfterBurn:(DRTrack*)track
{
	// required method
	<#statements_367#>
}
/*!
	@method			producePreGapForTrack:intoBuffer:length:atAddress:blockSize:ioFlags:
	@abstract		Produces the pregap data.
	@discussion		This method is called to obtain data for the track's pregap. If the @link DRPreGapLengthKey DRPreGapLengthKey @/link 
					key is present in the track properties, the track producer will be asked for the pregap 
					data first. If the producer implements this selector, then it's the responsibility
					of the producer to provide data for the pregap, otherwise that length of 
					silence will be produced by DiscRecording.
					
					The buffer passed in will be a multiple of blockSize (bufferLength == blockSize * N, where N > 1) 
					and should be filled as full as possible with data. address is the sector address on the disc from
					the start of the track that is the buffer will be written to.
					
					Since while burning, keeping the drive's buffer full is 
					of utmost importance, you should not perform lengthy operations or block for data in this method.
					This method should return the number of bytes actually in the buffer or 0 to indicate that there
					was an error producing the data.. 
	@param			track	The track object being burned
	@param			buffer	The buffer to place data into
	@param			bufferLength	The length of buffer
	@param			address	The on-disc address of where data will be written
	@param			blockSize	the size of each block on the disc. It's best to return a multiple of this size.
	@param			flags	flags
	@result			The number of bytes produced.
*/
- (uint32_t) producePreGapForTrack:(DRTrack*)track intoBuffer:(char*)buffer length:(uint32_t)bufferLength atAddress:(uint64_t)address blockSize:(uint32_t)blockSize ioFlags:(uint32_t*)flags
{
	// required method
	<#statements_368#>
}
/*!
	@method			produceDataForTrack:intoBuffer:length:atAddress:blockSize:ioFlags:
	@abstract		Produces the track data.
	@discussion		This method is called many times over the course of a burn to obtain data for the track. 
					The buffer passed in will be a multiple of blockSize (bufferLength == blockSize * N, where N > 1) 
					and should be filled as full as possible with data. address is the sector address on the disc from
					the start of the track that is the buffer will be written to.
					
					Since while burning, keeping the drive's buffer full is 
					of utmost importance, you should not perform lengthy operations or block for data in this method.
					This method should return the number of bytes actually in the buffer or 0 to indicate that there
					was an error producing the data.. 
	@param			track	The track object being burned
	@param			buffer	The buffer to place data into
	@param			bufferLength	The length of buffer
	@param			address	The on-disc address of where data will be written
	@param			blockSize	the size of each block on the disc. It's best to return a multiple of this size.
	@param			flags	flags
	@result			The number of bytes produced.
*/
- (uint32_t) produceDataForTrack:(DRTrack*)track intoBuffer:(char*)buffer length:(uint32_t)bufferLength atAddress:(uint64_t)address blockSize:(uint32_t)blockSize ioFlags:(uint32_t*)flags
{
	// required method
	<#statements_369#>
}
/*!
	@method			prepareTrackForVerification:
	@abstract		Prepare the track to be verified.
	@discussion		This method is called after the burn complets writing data to disc and before verification
					phase starts. Now would be a good time to prepare to produce data again by rewinding to the start
					of files, etc. 
	@param			track	The track object being burned
	@result			<i>YES</i> to indicate that the verification should proceed and <i>NO</i> to indicate a failure occurred.
*/
- (BOOL) prepareTrackForVerification:(DRTrack*)track
{
	// required method
	<#statements_370#>
}
/*!
	@method			verifyPreGapForTrack:inBuffer:length:atAddress:blockSize:ioFlags:
	@abstract		Checks the integrity track pregap after a burn.
	@discussion		If the class implementing this method asks for a verification type of @link DRVerificationTypeReceiveData DRVerificationTypeReceiveData @/link, 
					then a series of calls to this method will start. It's up to the class to reproduce the pregap
					again and compare it to the data passed in buffer. The buffer passed in will be a multiple of blockSize 
					(bufferLength == blockSize * N, where N > 1). address is the sector address on the disc from
					the start of the track that is the buffer was written to.
	@param			track	The track object being burned
	@param			buffer	The data read in from the track to compare with
	@param			bufferLength	The length of buffer
	@param			address	The on-disc address of where data will was read from.
	@param			blockSize	the size of each block on the disc. It's best to return a multiple of this size.
	@param			flags	flags
	@result			<i>YES</i> to indicate that the data compared successfully and <i>NO</i> to indicate a failure occurred.
*/
- (BOOL) verifyPreGapForTrack:(DRTrack*)track inBuffer:(const char*)buffer length:(uint32_t)bufferLength atAddress:(uint64_t)address blockSize:(uint32_t)blockSize ioFlags:(uint32_t*)flags
{
	// required method
	<#statements_371#>
}
/*!
	@method			verifyDataForTrack:inBuffer:length:atAddress:blockSize:ioFlags:
	@abstract		Cleans up the track after the burn completes.
	@discussion		If the class implementing this method asks for a verification type of @link DRVerificationTypeReceiveData DRVerificationTypeReceiveData @/link, 
					then a series of calls to this method will start. It's up to the class to reproduce the data
					again and compare it to the data passed in buffer. The buffer passed in will be a multiple of blockSize 
					(bufferLength == blockSize * N, where N > 1). address is the sector address on the disc from
					the start of the track that is the buffer was written to.
	@param			track	The track object being burned
	@param			buffer	The data read in from the track to compare with
	@param			bufferLength	The length of buffer
	@param			address	The on-disc address of where data will was read from.
	@param			blockSize	the size of each block on the disc. It's best to return a multiple of this size.
	@param			flags	flags
	@result			<i>YES</i> to indicate that the data compared successfully and <i>NO</i> to indicate a failure occurred.
*/
- (BOOL) verifyDataForTrack:(DRTrack*)track inBuffer:(const char*)buffer length:(uint32_t)bufferLength atAddress:(uint64_t)address blockSize:(uint32_t)blockSize ioFlags:(uint32_t*)flags
{
	// required method
	<#statements_372#>
}
/*!
	@method			cleanupTrackAfterVerification:
	@abstract		Cleans up the track after the verification completes.
	@discussion		Once the verification phase is complete, this method is called. The class implementing
					the method has a chance to do anything up to and including failing the verification. 
	@param			track	The track object being burned
	@result			Return <i>YES</i> to indicate success, <i>NO</i> to indicate failure.
*/
- (BOOL) cleanupTrackAfterVerification:(DRTrack*)track
{
	// required method
	<#statements_373#>
}
";
	},

	// 
	// Protocol NSCacheDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSCacheDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSCacheDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSCacheDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSCacheDelegate implementation
//

/*
- (void)cache:(NSCache *)cache willEvictObject:(id)obj
{
	// optional method
	<#statements_374#>
}
*/
";
	},

	// 
	// Protocol NSConnectionDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSConnectionDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSConnectionDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSConnectionDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSConnectionDelegate implementation
//

/*
- (BOOL)makeNewConnection:(NSConnection *)conn sender:(NSConnection *)ancestor
{
	// optional method
	<#statements_375#>
}
*/
/*
- (BOOL)connection:(NSConnection *)ancestor shouldMakeNewConnection:(NSConnection *)conn
{
	// optional method
	<#statements_376#>
}
*/
/*
- (NSData *)authenticationDataForComponents:(NSArray *)components
{
	// optional method
	<#statements_377#>
}
*/
/*
- (BOOL)authenticateComponents:(NSArray *)components withData:(NSData *)signature
{
	// optional method
	<#statements_378#>
}
*/
/*
- (id)createConversationForConnection:(NSConnection *)conn
{
	// optional method
	<#statements_379#>
}
*/
/*
- (BOOL)connection:(NSConnection *)connection handleRequest:(NSDistantObjectRequest *)doreq
{
	// optional method
	<#statements_380#>
}
*/
";
	},

	// 
	// Protocol NSDecimalNumberBehaviors
	// 
	{
		Identifier = objc.protocols10_6.NSDecimalNumberBehaviors;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSDecimalNumberBehaviors implementation (MacOSX 10.6)";
		CompletionPrefix = "NSDecimalNumberBehaviors";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSDecimalNumberBehaviors implementation
//

- (NSRoundingMode)roundingMode
{
	// required method
	<#statements_381#>
}
- (short)scale
{
	// required method
	<#statements_382#>
}
- (NSDecimalNumber *)exceptionDuringOperation:(SEL)operation error:(NSCalculationError)error leftOperand:(NSDecimalNumber *)leftOperand rightOperand:(NSDecimalNumber *)rightOperand
{
	// required method
	<#statements_383#>
}
";
	},

	// 
	// Protocol NSFastEnumeration
	// 
	{
		Identifier = objc.protocols10_6.NSFastEnumeration;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSFastEnumeration implementation (MacOSX 10.6)";
		CompletionPrefix = "NSFastEnumeration";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSFastEnumeration implementation
//

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id *)stackbuf count:(NSUInteger)len
{
	// required method
	<#statements_384#>
}
";
	},

	// 
	// Protocol NSKeyedArchiverDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSKeyedArchiverDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSKeyedArchiverDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSKeyedArchiverDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSKeyedArchiverDelegate implementation
//

/*
- (id)archiver:(NSKeyedArchiver *)archiver willEncodeObject:(id)object
{
	// optional method
	<#statements_385#>
}
*/
/*
- (void)archiver:(NSKeyedArchiver *)archiver didEncodeObject:(id)object
{
	// optional method
	<#statements_386#>
}
*/
/*
- (void)archiver:(NSKeyedArchiver *)archiver willReplaceObject:(id)object withObject:(id)newObject
{
	// optional method
	<#statements_387#>
}
*/
/*
- (void)archiverWillFinish:(NSKeyedArchiver *)archiver
{
	// optional method
	<#statements_388#>
}
*/
/*
- (void)archiverDidFinish:(NSKeyedArchiver *)archiver
{
	// optional method
	<#statements_389#>
}
*/
";
	},

	// 
	// Protocol NSKeyedUnarchiverDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSKeyedUnarchiverDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSKeyedUnarchiverDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSKeyedUnarchiverDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSKeyedUnarchiverDelegate implementation
//

/*
- (Class)unarchiver:(NSKeyedUnarchiver *)unarchiver cannotDecodeObjectOfClassName:(NSString *)name originalClasses:(NSArray *)classNames
{
	// optional method
	<#statements_390#>
}
*/
/*
- (id)unarchiver:(NSKeyedUnarchiver *)unarchiver didDecodeObject:(id)object
{
	// optional method
	<#statements_391#>
}
*/
/*
- (void)unarchiver:(NSKeyedUnarchiver *)unarchiver willReplaceObject:(id)object withObject:(id)newObject
{
	// optional method
	<#statements_392#>
}
*/
/*
- (void)unarchiverWillFinish:(NSKeyedUnarchiver *)unarchiver
{
	// optional method
	<#statements_393#>
}
*/
/*
- (void)unarchiverDidFinish:(NSKeyedUnarchiver *)unarchiver
{
	// optional method
	<#statements_394#>
}
*/
";
	},

	// 
	// Protocol NSLocking
	// 
	{
		Identifier = objc.protocols10_6.NSLocking;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSLocking implementation (MacOSX 10.6)";
		CompletionPrefix = "NSLocking";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSLocking implementation
//

- (void)lock
{
	// required method
	<#statements_395#>
}
- (void)unlock
{
	// required method
	<#statements_396#>
}
";
	},

	// 
	// Protocol NSMetadataQueryDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSMetadataQueryDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSMetadataQueryDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSMetadataQueryDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSMetadataQueryDelegate implementation
//

/*
- (id)metadataQuery:(NSMetadataQuery *)query replacementObjectForResultObject:(NSMetadataItem *)result
{
	// optional method
	<#statements_397#>
}
*/
/*
- (id)metadataQuery:(NSMetadataQuery *)query replacementValueForAttribute:(NSString *)attrName value:(id)attrValue
{
	// optional method
	<#statements_398#>
}
*/
";
	},

	// 
	// Protocol NSNetServiceDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSNetServiceDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSNetServiceDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSNetServiceDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSNetServiceDelegate implementation
//

/* Sent to the NSNetService instance's delegate prior to advertising the service on the network. If for some reason the service cannot be published, the delegate will not receive this message, and an error will be delivered to the delegate via the delegate's -netService:didNotPublish: method.
*/
/*
- (void)netServiceWillPublish:(NSNetService *)sender
{
	// optional method
	<#statements_399#>
}
*/
/* Sent to the NSNetService instance's delegate when the publication of the instance is complete and successful.
*/
/*
- (void)netServiceDidPublish:(NSNetService *)sender
{
	// optional method
	<#statements_400#>
}
*/
/* Sent to the NSNetService instance's delegate when an error in publishing the instance occurs. The error dictionary will contain two key/value pairs representing the error domain and code (see the NSNetServicesError enumeration above for error code constants). It is possible for an error to occur after a successful publication.
*/
/*
- (void)netService:(NSNetService *)sender didNotPublish:(NSDictionary *)errorDict
{
	// optional method
	<#statements_401#>
}
*/
/* Sent to the NSNetService instance's delegate prior to resolving a service on the network. If for some reason the resolution cannot occur, the delegate will not receive this message, and an error will be delivered to the delegate via the delegate's -netService:didNotResolve: method.
*/
/*
- (void)netServiceWillResolve:(NSNetService *)sender
{
	// optional method
	<#statements_402#>
}
*/
/* Sent to the NSNetService instance's delegate when one or more addresses have been resolved for an NSNetService instance. Some NSNetService methods will return different results before and after a successful resolution. An NSNetService instance may get resolved more than once; truly robust clients may wish to resolve again after an error, or to resolve more than once.
*/
/*
- (void)netServiceDidResolveAddress:(NSNetService *)sender
{
	// optional method
	<#statements_403#>
}
*/
/* Sent to the NSNetService instance's delegate when an error in resolving the instance occurs. The error dictionary will contain two key/value pairs representing the error domain and code (see the NSNetServicesError enumeration above for error code constants).
*/
/*
- (void)netService:(NSNetService *)sender didNotResolve:(NSDictionary *)errorDict
{
	// optional method
	<#statements_404#>
}
*/
/* Sent to the NSNetService instance's delegate when the instance's previously running publication or resolution request has stopped.
*/
/*
- (void)netServiceDidStop:(NSNetService *)sender
{
	// optional method
	<#statements_405#>
}
*/
/* Sent to the NSNetService instance's delegate when the instance is being monitored and the instance's TXT record has been updated. The new record is contained in the data parameter.
*/
/*
- (void)netService:(NSNetService *)sender didUpdateTXTRecordData:(NSData *)data
{
	// optional method
	<#statements_406#>
}
*/
";
	},

	// 
	// Protocol NSNetServiceBrowserDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSNetServiceBrowserDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSNetServiceBrowserDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSNetServiceBrowserDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSNetServiceBrowserDelegate implementation
//

/* Sent to the NSNetServiceBrowser instance's delegate before the instance begins a search. The delegate will not receive this message if the instance is unable to begin a search. Instead, the delegate will receive the -netServiceBrowser:didNotSearch: message.
*/
/*
- (void)netServiceBrowserWillSearch:(NSNetServiceBrowser *)aNetServiceBrowser
{
	// optional method
	<#statements_407#>
}
*/
/* Sent to the NSNetServiceBrowser instance's delegate when the instance's previous running search request has stopped.
*/
/*
- (void)netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)aNetServiceBrowser
{
	// optional method
	<#statements_408#>
}
*/
/* Sent to the NSNetServiceBrowser instance's delegate when an error in searching for domains or services has occurred. The error dictionary will contain two key/value pairs representing the error domain and code (see the NSNetServicesError enumeration above for error code constants). It is possible for an error to occur after a search has been started successfully.
*/
/*
- (void)netServiceBrowser:(NSNetServiceBrowser *)aNetServiceBrowser didNotSearch:(NSDictionary *)errorDict
{
	// optional method
	<#statements_409#>
}
*/
/* Sent to the NSNetServiceBrowser instance's delegate for each domain discovered. If there are more domains, moreComing will be YES. If for some reason handling discovered domains requires significant processing, accumulating domains until moreComing is NO and then doing the processing in bulk fashion may be desirable.
*/
/*
- (void)netServiceBrowser:(NSNetServiceBrowser *)aNetServiceBrowser didFindDomain:(NSString *)domainString moreComing:(BOOL)moreComing
{
	// optional method
	<#statements_410#>
}
*/
/* Sent to the NSNetServiceBrowser instance's delegate for each service discovered. If there are more services, moreComing will be YES. If for some reason handling discovered services requires significant processing, accumulating services until moreComing is NO and then doing the processing in bulk fashion may be desirable.
*/
/*
- (void)netServiceBrowser:(NSNetServiceBrowser *)aNetServiceBrowser didFindService:(NSNetService *)aNetService moreComing:(BOOL)moreComing
{
	// optional method
	<#statements_411#>
}
*/
/* Sent to the NSNetServiceBrowser instance's delegate when a previously discovered domain is no longer available.
*/
/*
- (void)netServiceBrowser:(NSNetServiceBrowser *)aNetServiceBrowser didRemoveDomain:(NSString *)domainString moreComing:(BOOL)moreComing
{
	// optional method
	<#statements_412#>
}
*/
/* Sent to the NSNetServiceBrowser instance's delegate when a previously discovered service is no longer published.
*/
/*
- (void)netServiceBrowser:(NSNetServiceBrowser *)aNetServiceBrowser didRemoveService:(NSNetService *)aNetService moreComing:(BOOL)moreComing
{
	// optional method
	<#statements_413#>
}
*/
";
	},

	// 
	// Protocol NSPortDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSPortDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSPortDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSPortDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSPortDelegate implementation
//

/*
- (void)handlePortMessage:(NSPortMessage *)message
{
	// optional method
	<#statements_414#>
}
*/
";
	},

	// 
	// Protocol NSMachPortDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSMachPortDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSMachPortDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSMachPortDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSMachPortDelegate implementation
//

/*
- (void)handleMachMessage:(void *)msg
{
	// optional method
	<#statements_415#>
}
*/
";
	},

	// 
	// Protocol NSSpellServerDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSSpellServerDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSSpellServerDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSSpellServerDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSSpellServerDelegate implementation
//

/*
- (NSRange)spellServer:(NSSpellServer *)sender findMisspelledWordInString:(NSString *)stringToCheck language:(NSString *)language wordCount:(NSInteger *)wordCount countOnly:(BOOL)countOnly
{
	// optional method
	<#statements_416#>
}
*/
/*
- (NSArray *)spellServer:(NSSpellServer *)sender suggestGuessesForWord:(NSString *)word inLanguage:(NSString *)language
{
	// optional method
	<#statements_417#>
}
*/
/*
- (void)spellServer:(NSSpellServer *)sender didLearnWord:(NSString *)word inLanguage:(NSString *)language
{
	// optional method
	<#statements_418#>
}
*/
/*
- (void)spellServer:(NSSpellServer *)sender didForgetWord:(NSString *)word inLanguage:(NSString *)language
{
	// optional method
	<#statements_419#>
}
*/
/*
- (NSArray *)spellServer:(NSSpellServer *)sender suggestCompletionsForPartialWordRange:(NSRange)range inString:(NSString *)string language:(NSString *)language
{
	// optional method
	<#statements_420#>
}
*/
#endif /* MAC_OS_X_VERSION_10_3 <= MAC_OS_X_VERSION_MAX_ALLOWED */
/*
- (NSRange)spellServer:(NSSpellServer *)sender checkGrammarInString:(NSString *)stringToCheck language:(NSString *)language details:(NSArray **)details
{
	// optional method
	<#statements_421#>
}
*/
/* Keys for the dictionaries in the details array. */
#endif /* MAC_OS_X_VERSION_10_5 <= MAC_OS_X_VERSION_MAX_ALLOWED */
/*
- (NSArray *)spellServer:(NSSpellServer *)sender checkString:(NSString *)stringToCheck offset:(NSUInteger)offset types:(NSTextCheckingTypes)checkingTypes options:(NSDictionary *)options orthography:(NSOrthography *)orthography wordCount:(NSInteger *)wordCount
{
	// optional method
	<#statements_422#>
}
*/
#endif /* MAC_OS_X_VERSION_10_6 <= MAC_OS_X_VERSION_MAX_ALLOWED */
";
	},

	// 
	// Protocol NSStreamDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSStreamDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSStreamDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSStreamDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSStreamDelegate implementation
//

/*
- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode
{
	// optional method
	<#statements_423#>
}
*/
";
	},

	// 
	// Protocol NSURLAuthenticationChallengeSender
	// 
	{
		Identifier = objc.protocols10_6.NSURLAuthenticationChallengeSender;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSURLAuthenticationChallengeSender implementation (MacOSX 10.6)";
		CompletionPrefix = "NSURLAuthenticationChallengeSender";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSURLAuthenticationChallengeSender implementation
//

/*!
    @method useCredential:forAuthenticationChallenge:
*/
- (void)useCredential:(NSURLCredential *)credential forAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
{
	// required method
	<#statements_424#>
}
/*!
    @method continueWithoutCredentialForAuthenticationChallenge:
*/
- (void)continueWithoutCredentialForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
{
	// required method
	<#statements_425#>
}
/*!
    @method cancelAuthenticationChallenge:
*/
- (void)cancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
{
	// required method
	<#statements_426#>
}
";
	},

	// 
	// Protocol NSURLProtocolClient
	// 
	{
		Identifier = objc.protocols10_6.NSURLProtocolClient;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSURLProtocolClient implementation (MacOSX 10.6)";
		CompletionPrefix = "NSURLProtocolClient";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSURLProtocolClient implementation
//

/*!
@method URLProtocol:wasRedirectedToRequest:
 @abstract Indicates to an NSURLProtocolClient that a redirect has
 occurred.
 @param URLProtocol the NSURLProtocol object sending the message.
 @param request the NSURLRequest to which the protocol implementation
 has redirected.
 */
- (void)URLProtocol:(NSURLProtocol *)protocol wasRedirectedToRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)redirectResponse
{
	// required method
	<#statements_427#>
}
    /*!
@method URLProtocol:cachedResponseIsValid:
     @abstract Indicates to an NSURLProtocolClient that the protocol
     implementation has examined a cached response and has
     determined that it is valid.
     @param URLProtocol the NSURLProtocol object sending the message.
     @param cachedResponse the NSCachedURLResponse object that has
     examined and is valid.
     */
- (void)URLProtocol:(NSURLProtocol *)protocol cachedResponseIsValid:(NSCachedURLResponse *)cachedResponse
{
	// required method
	<#statements_428#>
}
    /*!
@method URLProtocol:didReceiveResponse:
     @abstract Indicates to an NSURLProtocolClient that the protocol
     implementation has created an NSURLResponse for the current load.
     @param URLProtocol the NSURLProtocol object sending the message.
     @param response the NSURLResponse object the protocol implementation
     has created.
     @param cacheStoragePolicy The NSURLCacheStoragePolicy the protocol
     has determined should be used for the given response if the
     response is to be stored in a cache.
     */
- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveResponse:(NSURLResponse *)response cacheStoragePolicy:(NSURLCacheStoragePolicy)policy
{
	// required method
	<#statements_429#>
}
    /*!
@method URLProtocol:didLoadData:
     @abstract Indicates to an NSURLProtocolClient that the protocol
     implementation has loaded URL data.
     @discussion The data object must contain only new data loaded since
     the previous call to this method (if any), not cumulative data for
     the entire load.
     @param URLProtocol the NSURLProtocol object sending the message.
     @param data URL load data being made available.
     */
- (void)URLProtocol:(NSURLProtocol *)protocol didLoadData:(NSData *)data
{
	// required method
	<#statements_430#>
}
    /*!
@method URLProtocolDidFinishLoading:
     @abstract Indicates to an NSURLProtocolClient that the protocol
     implementation has finished loading successfully.
     @param URLProtocol the NSURLProtocol object sending the message.
     */
- (void)URLProtocolDidFinishLoading:(NSURLProtocol *)protocol
{
	// required method
	<#statements_431#>
}
    /*!
                @method URLProtocol:didFailWithError:
     @abstract Indicates to an NSURLProtocolClient that the protocol
     implementation has failed to load successfully.
     @param URLProtocol the NSURLProtocol object sending the message.
     @param error The error that caused the load to fail.
     */
- (void)URLProtocol:(NSURLProtocol *)protocol didFailWithError:(NSError *)error
{
	// required method
	<#statements_432#>
}
    /*!
@method URLProtocol:didReceiveAuthenticationChallenge:
     @abstract Start authentication for the specified request
     @param protocol The protocol object requesting authentication.
     @param challenge The authentication challenge.
     @discussion The protocol client guarantees that it will answer the
     request on the same thread that called this method. It may add a
     default credential to the challenge it issues to the connection delegate,
     if the protocol did not provide one.
     */
- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
{
	// required method
	<#statements_433#>
}
    /*!
@method URLProtocol:didCancelAuthenticationChallenge:
     @abstract Cancel authentication for the specified request
     @param protocol The protocol object cancelling authentication.
     @param challenge The authentication challenge.
     */
- (void)URLProtocol:(NSURLProtocol *)protocol didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
{
	// required method
	<#statements_434#>
}
";
	},

	// 
	// Protocol NSXMLParserDelegate
	// 
	{
		Identifier = objc.protocols10_6.NSXMLParserDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSXMLParserDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "NSXMLParserDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSXMLParserDelegate implementation
//

/*
- (void)parserDidStartDocument:(NSXMLParser *)parser
{
	// optional method
	<#statements_435#>
}
*/
/*
- (void)parserDidEndDocument:(NSXMLParser *)parser
{
	// optional method
	<#statements_436#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundNotationDeclarationWithName:(NSString *)name publicID:(NSString *)publicID systemID:(NSString *)systemID
{
	// optional method
	<#statements_437#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundUnparsedEntityDeclarationWithName:(NSString *)name publicID:(NSString *)publicID systemID:(NSString *)systemID notationName:(NSString *)notationName
{
	// optional method
	<#statements_438#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundAttributeDeclarationWithName:(NSString *)attributeName forElement:(NSString *)elementName type:(NSString *)type defaultValue:(NSString *)defaultValue
{
	// optional method
	<#statements_439#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundElementDeclarationWithName:(NSString *)elementName model:(NSString *)model
{
	// optional method
	<#statements_440#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundInternalEntityDeclarationWithName:(NSString *)name value:(NSString *)value
{
	// optional method
	<#statements_441#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundExternalEntityDeclarationWithName:(NSString *)name publicID:(NSString *)publicID systemID:(NSString *)systemID
{
	// optional method
	<#statements_442#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary *)attributeDict
{
	// optional method
	<#statements_443#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName
{
	// optional method
	<#statements_444#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser didStartMappingPrefix:(NSString *)prefix toURI:(NSString *)namespaceURI
{
	// optional method
	<#statements_445#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser didEndMappingPrefix:(NSString *)prefix
{
	// optional method
	<#statements_446#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string
{
	// optional method
	<#statements_447#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundIgnorableWhitespace:(NSString *)whitespaceString
{
	// optional method
	<#statements_448#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundProcessingInstructionWithTarget:(NSString *)target data:(NSString *)data
{
	// optional method
	<#statements_449#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundComment:(NSString *)comment
{
	// optional method
	<#statements_450#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser foundCDATA:(NSData *)CDATABlock
{
	// optional method
	<#statements_451#>
}
*/
/*
- (NSData *)parser:(NSXMLParser *)parser resolveExternalEntityName:(NSString *)name systemID:(NSString *)systemID
{
	// optional method
	<#statements_452#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser parseErrorOccurred:(NSError *)parseError
{
	// optional method
	<#statements_453#>
}
*/
/*
- (void)parser:(NSXMLParser *)parser validationErrorOccurred:(NSError *)validationError
{
	// optional method
	<#statements_454#>
}
*/
";
	},

	// 
	// Protocol ICCameraDeviceDelegate
	// 
	{
		Identifier = objc.protocols10_6.ICCameraDeviceDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "ICCameraDeviceDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "ICCameraDeviceDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: ICCameraDeviceDelegate implementation
//

/*! 
  @method cameraDevice:didAddItem:
  @abstract This message is sent when an object is added to the device.
  @discussion The object may be an instance of ICCameraFolder or ICCameraFile class.
*/
/*
- (void)cameraDevice:(ICCameraDevice*)camera didAddItem:(ICCameraItem*)item
{
	// optional method
	<#statements_455#>
}
*/
/*! 
  @method cameraDevice:didRemoveItem:
  @abstract This message is sent when an object is removed from the device.
  @discussion The object may be an instance of ICCameraFolder or ICCameraFile class.
*/
/*
- (void)cameraDevice:(ICCameraDevice*)camera didRemoveItem:(ICCameraItem*)item
{
	// optional method
	<#statements_456#>
}
*/
/*! 
  @method cameraDeviceDidChangeCapability:
  @abstract This message is sent when the capability of a device changes.
  @discussion This usually happens when the device module takes control or yields control of the device.
*/
/*
- (void)cameraDeviceDidChangeCapability:(ICCameraDevice*)camera
{
	// optional method
	<#statements_457#>
}
*/
/*! 
  @method cameraDevice:didReceiveThumbnailForItem:
  @abstract This message is sent when the thumbnail requested for an item on a device is available.
*/
/*
- (void)cameraDevice:(ICCameraDevice*)camera didReceiveThumbnailForItem:(ICCameraItem*)item
{
	// optional method
	<#statements_458#>
}
*/
/*! 
  @method cameraDevice:didReceiveMetadataForItem:
  @abstract This message is sent when the metadata requested for an item on a device is available.
*/
/*
- (void)cameraDevice:(ICCameraDevice*)camera didReceiveMetadataForItem:(ICCameraItem*)item
{
	// optional method
	<#statements_459#>
}
*/
/*! 
  @method cameraDevice:didReceivePTPEvent:
  @abstract This message is sent to the delegate to convey a PTP event.
*/
/*
- (void)cameraDevice:(ICCameraDevice*)camera didReceivePTPEvent:(NSData*)eventData
{
	// optional method
	<#statements_460#>
}
*/
";
	},

	// 
	// Protocol ICDeviceDelegate
	// 
	{
		Identifier = objc.protocols10_6.ICDeviceDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "ICDeviceDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "ICDeviceDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: ICDeviceDelegate implementation
//

/*! 
  @method didRemoveDevice:
  @abstract This message is sent to the delegate to inform that a device has been removed.
*/
- (void)didRemoveDevice:(ICDevice*)device
{
	// required method
	<#statements_461#>
}
/*! 
  @method device:didOpenSessionWithError:
  @abstract This message is sent when a session is opened on a device.
  @discussion This message completes the process initiated by the message \"requestOpenSession\" sent to the device object.
*/
/*
- (void)device:(ICDevice*)device didOpenSessionWithError:(NSError*)error
{
	// optional method
	<#statements_462#>
}
*/
/*! 
  @method deviceDidBecomeReady:
  @abstract This message is sent when the device is ready.
  @discusson A camera device is ready, when its contents are enumerated. A scanner device is ready when its functional units are found and the default functional unit is selected for use.
*/
/*
- (void)deviceDidBecomeReady:(ICDevice*)device
{
	// optional method
	<#statements_463#>
}
*/
/*! 
  @method device:didCloseSessionWithError:
  @abstract This message is sent when a session is closed on a device.
  @discussion This message completes the process initiated by the message \"requestCloseSession\" sent to the device object. This message is also sent if the device module in control of the device ceases to control the device.
*/
/*
- (void)device:(ICDevice*)device didCloseSessionWithError:(NSError*)error
{
	// optional method
	<#statements_464#>
}
*/
/*! 
  @method deviceDidChangeName:
  @abstract This message is sent if the name of a device changes.
  @discussion This happens if the device module overrides the default name of the device reported by the device's transport layer, or if the name of the filesystem volume mounted by the device is changed by the user.
*/
/*
- (void)deviceDidChangeName:(ICDevice*)device
{
	// optional method
	<#statements_465#>
}
*/
/*! 
  @method deviceDidChangeSharingState:
  @abstract This message is sent when the sharing state of a device has changes.
  @discusson Any Image Capture client application can choose to share the device over the network using the sharing or webSharing facility in Image Capture.
*/
/*
- (void)deviceDidChangeSharingState:(ICDevice*)device
{
	// optional method
	<#statements_466#>
}
*/
/*! 
  @method device:didReceiveStatusInformation:
  @abstract This message is sent to the device delegate when status information is received from a camera or a scanner. In Mac OS X 10.6 this delegate is not called for camera devices. This may change in the future releases of Mac OS X.
  @discussion The 'status' dictionary contains two keys, ICStatusNotificationKey and ICLocalizedStatusNotificationKey, which are defined above. If type of 'device' is ICDeviceTypeScanner, the value of ICStatusNotificationKey will be one of the values defined in ICScannerDevice.h (e.g., ICScannerStatusWarmingUp, ICScannerStatusWarmUpDone, or ICScannerStatusRequestsOverviewScan); the value of ICLocalizedStatusNotificationKey will be a localized status information string suitable for displaying to the user. */
/*
- (void)device:(ICDevice*)device didReceiveStatusInformation:(NSDictionary*)status
{
	// optional method
	<#statements_467#>
}
*/
/*! 
  @method scannerDevice:didEncounterError:
  @abstract This message is sent to the device delegate when a camera or scanner device encounters an error.
*/
/*
- (void)device:(ICDevice*)device didEncounterError:(NSError*)error
{
	// optional method
	<#statements_468#>
}
*/
/*! 
  @method device:didReceiveButtonPress:
  @abstract This message is sent to the device delegate if a button is pressed on the device.
  @discussion This message is sent only if a session is open on the device. The value of 'buttonType' argument is one of the ICButtonType* values defined above.
*/
/*
- (void)device:(ICDevice*)device didReceiveButtonPress:(NSString*)buttonType
{
	// optional method
	<#statements_469#>
}
*/
";
	},

	// 
	// Protocol ICDeviceBrowserDelegate
	// 
	{
		Identifier = objc.protocols10_6.ICDeviceBrowserDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "ICDeviceBrowserDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "ICDeviceBrowserDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: ICDeviceBrowserDelegate implementation
//

/*! 
  @method deviceBrowser:didAddDevice:moreComing:
  @abstract This message is sent to the delegate to inform that a device has been added.
  @discussion If several devices are found during the initial search, then this message is sent once for each device with the value of 'moreComing' set to YES in each message except the last one. 
*/
- (void)deviceBrowser:(ICDeviceBrowser*)browser didAddDevice:(ICDevice*)device moreComing:(BOOL)moreComing
{
	// required method
	<#statements_470#>
}
/*! 
  @method deviceBrowser:didRemoveDevice:moreGoing:
  @abstract This message is sent to the delegate to inform that a device has been removed.
  @discussion If several devices are removed at the same time, then this message is sent once for each device with the value of 'moreGoing' set to YES in each message except the last one. 
*/
- (void)deviceBrowser:(ICDeviceBrowser*)browser didRemoveDevice:(ICDevice*)device moreGoing:(BOOL)moreGoing
{
	// required method
	<#statements_471#>
}
/*! 
  @method deviceBrowser:deviceDidChangeName:
  @abstract This message is sent if the name of a device changes.
  @discussion This happens if the device module overrides the default name of the device reported by the device's transport layer, or if the name of the filesystem volume mounted by the device is changed by the user.
*/
/*
- (void)deviceBrowser:(ICDeviceBrowser*)browser deviceDidChangeName:(ICDevice*)device
{
	// optional method
	<#statements_472#>
}
*/
/*! 
  @method deviceBrowser:deviceDidChangeSharingState:
  @abstract This message is sent when the sharing state of a device has changes.
  @discusson Any Image Capture client application can choose to share the device over the network using the sharing or webSharing facility in Image Capture.
*/
/*
- (void)deviceBrowser:(ICDeviceBrowser*)browser deviceDidChangeSharingState:(ICDevice*)device
{
	// optional method
	<#statements_473#>
}
*/
/*! 
  @method deviceBrowser:requestsSelectDevice:
  @abstract This message is sent when an event that occurred on the device may be of interest to the client application.
  @discussion In Mac OS X 10.6, this message is sent when a button is pressed on a device and the current application is the target for that button press. In the case of the button-press event, if a session is open on the device, this message will not be sent to the browser delegate, instead the message 'device:didReceiveButtonPress:' is sent to the device delegate.
*/
/*
- (void)deviceBrowser:(ICDeviceBrowser*)browser requestsSelectDevice:(ICDevice*)device
{
	// optional method
	<#statements_474#>
}
*/
/*! 
  @method deviceBrowserDidEnumerateLocalDevices:deviceDidChangeSharingState:
  @abstract This message is sent after the device browser completes sending 'deviceBrowser:didAddDevice:moreComing:' message for all local devices.
  @discusson Detecting locally connected devices (USB and FireWire devices) is faster than detecting devices connected using a network protocol. An Image Capture client application may use this message to update its user interface to let the user know that it has completed looking for locally connected devices and then start looking for network devices.
*/
/*
- (void)deviceBrowserDidEnumerateLocalDevices:(ICDeviceBrowser*)browser
{
	// optional method
	<#statements_475#>
}
*/
";
	},

	// 
	// Protocol ICScannerDeviceDelegate
	// 
	{
		Identifier = objc.protocols10_6.ICScannerDeviceDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "ICScannerDeviceDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "ICScannerDeviceDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: ICScannerDeviceDelegate implementation
//

/*! 
  @method scannerDeviceDidBecomeAvailable:
  @abstract This message is sent when another client closes an open session on the scanner.
  @discusson Scanners require exclusive access, only one client can open a session on a scanner. The scanner is available if it does not have a session opened by another client. Attempting to open a session on a scanner that already has an open session for another client will result in an error. A client that wants to open a session on a scanner as soon as it is available should implement this method and send \"requestOpenSession\" message to scanner object from that method.
*/
/*
- (void)scannerDeviceDidBecomeAvailable:(ICScannerDevice*)scanner
{
	// optional method
	<#statements_476#>
}
*/
/*! 
  @method scannerDevice:didSelectFunctionalUnit:error:
  @abstract This message is sent when a functional unit is selected on the scanner device.
  @discusson A functional unit is selected immediately after the scanner device is instantiated and in response to \"requestSelectFunctionalUnit:\" message.
*/
/*
- (void)scannerDevice:(ICScannerDevice*)scanner didSelectFunctionalUnit:(ICScannerFunctionalUnit*)functionalUnit error:(NSError*)error
{
	// optional method
	<#statements_477#>
}
*/
/*! 
  @method scannerDevice:didScanToURL:data:
  @abstract This message is sent when the scanner device receives the requested scan. If selectedFunctionalUnit is a document feeder, then this message will be sent once for each scanned page.
  @discusson This message is sent when the scanner device receives the requested scan. If selectedFunctionalUnit is a document feeder, then this message will be sent once for each scanned page.
*/
/*
- (void)scannerDevice:(ICScannerDevice*)scanner didScanToURL:(NSURL*)url data:(NSData*)data
{
	// optional method
	<#statements_478#>
}
*/
/*! 
  @method scannerDevice:didCompleteOverviewScanWithError:
  @abstract This message is sent after the scanner device completes an overview scan.
  @discusson This message is sent after the scanner device completes an overview scan.
*/
/*
- (void)scannerDevice:(ICScannerDevice*)scanner didCompleteOverviewScanWithError:(NSError*)error
{
	// optional method
	<#statements_479#>
}
*/
/*! 
  @method scannerDevice:didCompleteScanWithError:
  @abstract This message is sent after the scanner device completes a scan.
  @discusson This message is sent after the scanner device completes a scan.
*/
/*
- (void)scannerDevice:(ICScannerDevice*)scanner didCompleteScanWithError:(NSError*)error
{
	// optional method
	<#statements_480#>
}
*/
";
	},

	// 
	// Protocol IMKStateSetting
	// 
	{
		Identifier = objc.protocols10_6.IMKStateSetting;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IMKStateSetting implementation (MacOSX 10.6)";
		CompletionPrefix = "IMKStateSetting";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IMKStateSetting implementation
//

/*!
    @method     
    @abstract   Activates the input method.
*/
- (void)activateServer:(id)sender
{
	// required method
	<#statements_481#>
}
/*!
    @method     
    @abstract   Deactivate the input method.
*/
- (void)deactivateServer:(id)sender
{
	// required method
	<#statements_482#>
}
/*!
    @method     
    @abstract   Return a object value whose key is tag.  The returned object should be autoreleased.
*/
- (id)valueForTag:(long)tag client:(id)sender
{
	// required method
	<#statements_483#>
}
/*!
    @method     
    @abstract   Set the tagged value to the object specified by value.
*/
- (void)setValue:(id)value forTag:(long)tag client:(id)sender
{
	// required method
	<#statements_484#>
}
/*!
    @method     
    @abstract   This is called to obtain the input method's modes dictionary.  
    @discussion Typically this is called to to build the text input menu.  By calling the input method rather than reading the modes from the info.plist the input method can dynamically modify he modes supported. The returned NSDictionary should be an autoreleased object.
*/
- (NSDictionary*)modes:(id)sender
{
	// required method
	<#statements_485#>
}
/*!
    @method      
    @abstract   Returns an unsigned integer containing a union of event masks (see NSEvent.h)
    @discussion A client will check with an input method to see if an event is supported by calling the method.  The default implementation returns NSKeyDownMask. 
				If your input method only handles key downs the InputMethodKit provides default mouse handling.  The default mousedown handling behavior is as follows: if there is an active composition area and the user clicks in the text but outside of the composition area the InputMethodKit will send your input method a commitComposition: message. Note that this will only happen for input methods that return just NSKeyDownMask (i.e. the default value) as the result of recognizedEvents.
*/
- (NSUInteger)recognizedEvents:(id)sender
{
	// required method
	<#statements_486#>
}
/*!
    @method      
    @abstract   Looks for a nib file containing a windowController class and a preferences utility. If found the panel is displayed.
    @discussion To use this method include a menu item whose action is showPreferences: in your input method's menu.  If that is done the method will be called automatically when a user selects the item in the Text Input Menu.  
    The default implementation looks for a nib file called preferences.nib.  If found a windowController class is allocated and the nib is loaded.  You can provide a custom windowController class by naming the class in your input methods info.plist file.  To do that provide a string value that names the custom class with a key of InputMethodServerPreferencesWindowControllerClass.  
*/
- (void)showPreferences:(id)sender
{
	// required method
	<#statements_487#>
}
";
	},

	// 
	// Protocol IMKMouseHandling
	// 
	{
		Identifier = objc.protocols10_6.IMKMouseHandling;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IMKMouseHandling implementation (MacOSX 10.6)";
		CompletionPrefix = "IMKMouseHandling";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IMKMouseHandling implementation
//

/*!
    @method
    
    @abstract   Sends a mouseDown to an input method.
    @discussion A mouse down event happened at given index within the senders text storage, at the given point, and with modifier keys identified in flags. Return YES if handled.  Set keepTracking to YES if you want to receive subsequent mouseMoved and mouseUp events.
*/
-(BOOL)mouseDownOnCharacterIndex:(NSUInteger)index coordinate:(NSPoint)point withModifier:(NSUInteger)flags continueTracking:(BOOL*)keepTracking client:(id)sender
{
	// required method
	<#statements_488#>
}
/*!
    @method
    
    @abstract   Sends a mouseUp to an input method.
    @discussion A mouse up event happened at given index within the sender text views text storage, at the given point, with modifier keys identified in flags. Return YES if handled.
*/
-(BOOL)mouseUpOnCharacterIndex:(NSUInteger)index coordinate:(NSPoint)point withModifier:(NSUInteger)flags client:(id)sender
{
	// required method
	<#statements_489#>
}
/*!
    @method
    
    @abstract   Passes a mouseMoved event to the input method.
    @discussion A mouse moved event happened at given index within the sender text views text storage, at the given point, with modifier keys identified in flags. Return YES if handled.
*/
-(BOOL)mouseMovedOnCharacterIndex:(NSUInteger)index coordinate:(NSPoint)point withModifier:(NSUInteger)flags client:(id)sender
{
	// required method
	<#statements_490#>
}
";
	},

	// 
	// Protocol IOBluetoothDeviceAsyncCallbacks
	// 
	{
		Identifier = objc.protocols10_6.IOBluetoothDeviceAsyncCallbacks;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IOBluetoothDeviceAsyncCallbacks implementation (MacOSX 10.6)";
		CompletionPrefix = "IOBluetoothDeviceAsyncCallbacks";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IOBluetoothDeviceAsyncCallbacks implementation
//

- (void)remoteNameRequestComplete:(IOBluetoothDevice *)device status:(IOReturn)status
{
	// required method
	<#statements_491#>
}
- (void)connectionComplete:(IOBluetoothDevice *)device status:(IOReturn)status
{
	// required method
	<#statements_492#>
}
- (void)sdpQueryComplete:(IOBluetoothDevice *)device status:(IOReturn)status
{
	// required method
	<#statements_493#>
}
";
	},

	// 
	// Protocol IOBluetoothL2CAPChannelDelegate
	// 
	{
		Identifier = objc.protocols10_6.IOBluetoothL2CAPChannelDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IOBluetoothL2CAPChannelDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "IOBluetoothL2CAPChannelDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IOBluetoothL2CAPChannelDelegate implementation
//

- (void)l2capChannelData:(IOBluetoothL2CAPChannel*)l2capChannel data:(void *)dataPointer length:(size_t)dataLength
{
	// required method
	<#statements_494#>
}
- (void)l2capChannelOpenComplete:(IOBluetoothL2CAPChannel*)l2capChannel status:(IOReturn)error
{
	// required method
	<#statements_495#>
}
- (void)l2capChannelClosed:(IOBluetoothL2CAPChannel*)l2capChannel
{
	// required method
	<#statements_496#>
}
- (void)l2capChannelReconfigured:(IOBluetoothL2CAPChannel*)l2capChannel
{
	// required method
	<#statements_497#>
}
- (void)l2capChannelWriteComplete:(IOBluetoothL2CAPChannel*)l2capChannel refcon:(void*)refcon status:(IOReturn)error
{
	// required method
	<#statements_498#>
}
- (void)l2capChannelQueueSpaceAvailable:(IOBluetoothL2CAPChannel*)l2capChannel
{
	// required method
	<#statements_499#>
}
";
	},

	// 
	// Protocol IOBluetoothRFCOMMChannelDelegate
	// 
	{
		Identifier = objc.protocols10_6.IOBluetoothRFCOMMChannelDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IOBluetoothRFCOMMChannelDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "IOBluetoothRFCOMMChannelDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IOBluetoothRFCOMMChannelDelegate implementation
//

- (void)rfcommChannelData:(IOBluetoothRFCOMMChannel*)rfcommChannel data:(void *)dataPointer length:(size_t)dataLength
{
	// required method
	<#statements_500#>
}
- (void)rfcommChannelOpenComplete:(IOBluetoothRFCOMMChannel*)rfcommChannel status:(IOReturn)error
{
	// required method
	<#statements_501#>
}
- (void)rfcommChannelClosed:(IOBluetoothRFCOMMChannel*)rfcommChannel
{
	// required method
	<#statements_502#>
}
- (void)rfcommChannelControlSignalsChanged:(IOBluetoothRFCOMMChannel*)rfcommChannel
{
	// required method
	<#statements_503#>
}
- (void)rfcommChannelFlowControlChanged:(IOBluetoothRFCOMMChannel*)rfcommChannel
{
	// required method
	<#statements_504#>
}
- (void)rfcommChannelWriteComplete:(IOBluetoothRFCOMMChannel*)rfcommChannel refcon:(void*)refcon status:(IOReturn)error
{
	// required method
	<#statements_505#>
}
- (void)rfcommChannelQueueSpaceAvailable:(IOBluetoothRFCOMMChannel*)rfcommChannel
{
	// required method
	<#statements_506#>
}
";
	},

	// 
	// Protocol AWTCocoaComponent
	// 
	{
		Identifier = objc.protocols10_6.AWTCocoaComponent;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "AWTCocoaComponent implementation (MacOSX 10.6)";
		CompletionPrefix = "AWTCocoaComponent";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: AWTCocoaComponent implementation
//

-(void)awtMessage:(jint)messageID message:(jobject)message env:(JNIEnv*)env
{
	// required method
	<#statements_507#>
}
";
	},

	// 
	// Protocol JNFTypeCoercion
	// 
	{
		Identifier = objc.protocols10_6.JNFTypeCoercion;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "JNFTypeCoercion implementation (MacOSX 10.6)";
		CompletionPrefix = "JNFTypeCoercion";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: JNFTypeCoercion implementation
//

- (jobject) coerceNSObject:(id)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer
{
	// required method
	<#statements_508#>
}
- (id) coerceJavaObject:(jobject)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer
{
	// required method
	<#statements_509#>
}
";
	},

	// 
	// Protocol AWTCocoaComponent
	// 
	{
		Identifier = objc.protocols10_6.AWTCocoaComponent;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "AWTCocoaComponent implementation (MacOSX 10.6)";
		CompletionPrefix = "AWTCocoaComponent";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: AWTCocoaComponent implementation
//

-(void)awtMessage:(jint)messageID message:(jobject)message env:(JNIEnv*)env
{
	// required method
	<#statements_510#>
}
";
	},

	// 
	// Protocol ODQueryDelegate
	// 
	{
		Identifier = objc.protocols10_6.ODQueryDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "ODQueryDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "ODQueryDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: ODQueryDelegate implementation
//

- (void)query:(ODQuery *)inQuery foundResults:(NSArray *)inResults error:(NSError *)inError
{
	// required method
	<#statements_511#>
}
";
	},

	// 
	// Protocol IKCameraDeviceViewDelegate
	// 
	{
		Identifier = objc.protocols10_6.IKCameraDeviceViewDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IKCameraDeviceViewDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "IKCameraDeviceViewDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IKCameraDeviceViewDelegate implementation
//

/*! 
 @method cameraDeviceViewSelectionDidChange:
 @abstract This message is sent when the user selection did change.
 */
/*
- (void)cameraDeviceViewSelectionDidChange: (IKCameraDeviceView *)cameraDeviceView
{
	// optional method
	<#statements_512#>
}
*/
/*! 
 @method cameraDeviceView:didDownloadFile:location:fileData:error:
 @abstract This message is sent for each file that gets downloaded.
 @discussion Based on the IKCameraDeviceViewDisplayMode the downloaded file will be saved on disk using the 'url', or returned in memory as NSData
 */
/*
- (void)cameraDeviceView: (IKCameraDeviceView *)cameraDeviceView didDownloadFile: (ICCameraFile *)file location: (NSURL *)url fileData: (NSData *)data error: (NSError *)error
{
	// optional method
	<#statements_513#>
}
*/
/*! 
 @method cameraDeviceView:didEncounterError:
 @abstract This message is sent every time the camera device reports an error.
 */
/*
- (void)cameraDeviceView: (IKCameraDeviceView *)cameraDeviceView didEncounterError: (NSError *)error
{
	// optional method
	<#statements_514#>
}
*/
";
	},

	// 
	// Protocol IKDeviceBrowserViewDelegate
	// 
	{
		Identifier = objc.protocols10_6.IKDeviceBrowserViewDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IKDeviceBrowserViewDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "IKDeviceBrowserViewDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IKDeviceBrowserViewDelegate implementation
//

/*! 
 @method deviceBrowserView:selectionDidChange:
 @abstract This message is sent when the user selection did change.
 @discussion The device may be a ICCameraDevice or a ICScannerDevice.
 */
- (void)deviceBrowserView: (IKDeviceBrowserView *)deviceBrowserView selectionDidChange: (ICDevice *)device
{
	// required method
	<#statements_515#>
}
/*! 
 @method deviceBrowserView:didEncounterError:
 @abstract This message is sent every time the device browser reports an error.
 */
/*
- (void)deviceBrowserView: (IKDeviceBrowserView *)deviceBrowserView didEncounterError: (NSError *)error
{
	// optional method
	<#statements_516#>
}
*/
";
	},

	// 
	// Protocol IKFilterCustomUIProvider
	// 
	{
		Identifier = objc.protocols10_6.IKFilterCustomUIProvider;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IKFilterCustomUIProvider implementation (MacOSX 10.6)";
		CompletionPrefix = "IKFilterCustomUIProvider";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IKFilterCustomUIProvider implementation
//

/*!
    @method     provideViewForUIConfiguration:excludedKeys:
    @abstract   The provideViewForUIConfiguration gets called, when a client requests a filter UI by calling viewForUIConfiguration:excludedKeys.
    @discussion See description in viewForUIConfiguration:excludedKeys for details on the parameters. If a filter cannot provide a IKFilterUIView for a given UIConfiguration, it can return nil and the CoreImageKit framework will try to provide a UI for it instead.
*/
-(IKFilterUIView*)provideViewForUIConfiguration:(NSDictionary*)inUIConfiguration excludedKeys:(NSArray*)inKeys
{
	// required method
	<#statements_517#>
}
";
	},

	// 
	// Protocol IKImageEditPanelDataSource
	// 
	{
		Identifier = objc.protocols10_6.IKImageEditPanelDataSource;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IKImageEditPanelDataSource implementation (MacOSX 10.6)";
		CompletionPrefix = "IKImageEditPanelDataSource";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IKImageEditPanelDataSource implementation
//

/*! 
 @method image
 @abstract Returns an image.
 */
- (CGImageRef)image
{
	// required method
	<#statements_518#>
}
/*! 
 @method setImage:imageProperties:
 @abstract Sets an image with the specifies properties.
 */
- (void)setImage: (CGImageRef)image
 imageProperties: (NSDictionary *)metaData
{
	// required method
	<#statements_519#>
}
/*! 
 @method thumbnailWithMaximumSize:
 @abstract Returns a thumbnail image whose size is no larger than the specified size.
 */
/*
- (CGImageRef)thumbnailWithMaximumSize: (NSSize)size
{
	// optional method
	<#statements_520#>
}
*/
/*! 
 @method imageProperties
 @abstract Returns a dictionary of the image properties associated with the image in the image edit panel.
 */
/*
- (NSDictionary *)imageProperties
{
	// optional method
	<#statements_521#>
}
*/
/*! 
 @method hasAdjustMode
 @abstract Show the adjust view tab
 */
/*
- (BOOL)hasAdjustMode
{
	// optional method
	<#statements_522#>
}
*/
/*! 
 @method hasEffectsMode
 @abstract Show the effects view tab
 */
/*
- (BOOL)hasEffectsMode
{
	// optional method
	<#statements_523#>
}
*/
/*! 
 @method hasDetailsMode
 @abstract Show the details view tab
 */
/*
- (BOOL)hasDetailsMode
{
	// optional method
	<#statements_524#>
}
*/
";
	},

	// 
	// Protocol IKScannerDeviceViewDelegate
	// 
	{
		Identifier = objc.protocols10_6.IKScannerDeviceViewDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IKScannerDeviceViewDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "IKScannerDeviceViewDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IKScannerDeviceViewDelegate implementation
//

/*! 
 @method scannerDeviceView:didScanToURL:fileData:error:
 @abstract This message is sent for each image that gets scanned.
 @discussion Based on the IKScannerDeviceViewTransferMode the downloaded file will be saved on disk using the 'url', or returned in memory as NSData
 */
/*
- (void)scannerDeviceView: (IKScannerDeviceView *)scannerDeviceView didScanToURL: (NSURL *)url fileData: (NSData *)data error: (NSError *)error
{
	// optional method
	<#statements_525#>
}
*/
/*! 
 @method scannerDeviceView:didEncounterError:
 @abstract This message is sent every time the scanner device reports an error.
 */
/*
- (void)scannerDeviceView: (IKScannerDeviceView *)scannerDeviceView didEncounterError: (NSError *)error
{
	// optional method
	<#statements_526#>
}
*/
";
	},

	// 
	// Protocol IKSlideshowDataSource
	// 
	{
		Identifier = objc.protocols10_6.IKSlideshowDataSource;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "IKSlideshowDataSource implementation (MacOSX 10.6)";
		CompletionPrefix = "IKSlideshowDataSource";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: IKSlideshowDataSource implementation
//

/*! 
 @method numberOfSlideshowItems
 @abstract return number of items in Slideshow.
 */
- (NSUInteger)numberOfSlideshowItems
{
	// required method
	<#statements_527#>
}
/*! 
 @method slideshowItemAtIndex:
 @abstract return the item for a given index.
 @discussion The item can be either: NSImage, NSString, NSURL, CGImageRef, or PDFPage.
             Note: when using 'IKSlideshowModeOther' as slideshowMode, the item has to be a NSURL.
 */
- (id)slideshowItemAtIndex: (NSUInteger)index
{
	// required method
	<#statements_528#>
}
/*! 
 @method nameOfSlideshowItemAtIndex:
 @abstract Display name for item at index.
 */
/*
- (NSString *)nameOfSlideshowItemAtIndex: (NSUInteger)index
{
	// optional method
	<#statements_529#>
}
*/
/*! 
 @method canExportSlideshowItemAtIndex:toApplication:
 @abstract should the export button be enabled for a given item at index?
 */
/*
- (BOOL)canExportSlideshowItemAtIndex: (NSUInteger)index toApplication: (NSString *)applicationBundleIdentifier
{
	// optional method
	<#statements_530#>
}
*/
/*! 
 @method slideshowWillStart
 @abstract Slideshow will start.
 */
/*
- (void)slideshowWillStart
{
	// optional method
	<#statements_531#>
}
*/
/*! 
 @method slideshowDidStop
 @abstract Slideshow did stop.
 */
/*
- (void)slideshowDidStop
{
	// optional method
	<#statements_532#>
}
*/
/*! 
 @method slideshowDidChangeCurrentIndex:
 @abstract Slideshow did change current item index.
 */
/*
- (void)slideshowDidChangeCurrentIndex: (NSUInteger)newIndex
{
	// optional method
	<#statements_533#>
}
*/
";
	},

	// 
	// Protocol QLPreviewItem
	// 
	{
		Identifier = objc.protocols10_6.QLPreviewItem;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "QLPreviewItem implementation (MacOSX 10.6)";
		CompletionPrefix = "QLPreviewItem";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: QLPreviewItem implementation
//

/*!
 * @abstract The URL of the item to preview.
 * @discussion The URL must be a file URL. Return nil if the item is not available for preview (The Preview Panel or View will then display the Loading view).
 */
/*!
 * @abstract The item's title this will be used as apparent item title.
 * @discussion The title replaces the default item display name. This property is optional.
 */
/*!
 * @abstract The preview display state (e.g.: visible page).
 * @discussion The display state is an opaque object used by the Preview Panel and Preview Views. This property is optional.
 */
";
	},

	// 
	// Protocol QLPreviewPanelDataSource
	// 
	{
		Identifier = objc.protocols10_6.QLPreviewPanelDataSource;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "QLPreviewPanelDataSource implementation (MacOSX 10.6)";
		CompletionPrefix = "QLPreviewPanelDataSource";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: QLPreviewPanelDataSource implementation
//

/*!
 * @abstract Returns the number of items that the preview panel should preview.
 * @param panel The Preview Panel.
 * @result The number of items.
 */
- (NSInteger)numberOfPreviewItemsInPreviewPanel:(QLPreviewPanel *)panel
{
	// required method
	<#statements_534#>
}
/*!
 * @abstract Returns the item that the preview panel should preview.
 * @param panel The Preview Panel.
 * @param index The index of the item to preview.
 * @result An item conforming to the QLPreviewItem protocol.
 */
- (id <QLPreviewItem>)previewPanel:(QLPreviewPanel *)panel previewItemAtIndex:(NSInteger)index
{
	// required method
	<#statements_535#>
}
";
	},

	// 
	// Protocol QLPreviewPanelDelegate
	// 
	{
		Identifier = objc.protocols10_6.QLPreviewPanelDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "QLPreviewPanelDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "QLPreviewPanelDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: QLPreviewPanelDelegate implementation
//

/*!
 * @abstract Invoked by the preview panel when it receives an event it doesn't handle.
 * @result Returns NO if the receiver did not handle the event.
 * 
 */
/*
- (BOOL)previewPanel:(QLPreviewPanel *)panel handleEvent:(NSEvent *)event
{
	// optional method
	<#statements_536#>
}
*/
/*
 * Zoom effect
 */
/*!
 * @abstract Invoked when the preview panel opens or closes to provide a zoom effect.
 * @discussion Return NSZeroRect if there is no origin point, this will produce a fade of the panel. The coordinates are screen based.
 */
/*
- (NSRect)previewPanel:(QLPreviewPanel *)panel sourceFrameOnScreenForPreviewItem:(id <QLPreviewItem>)item
{
	// optional method
	<#statements_537#>
}
*/
/*!
 * @abstract Invoked when the preview panel opens or closes to provide a smooth transition when zooming.
 * @param contentRect The rect within the image that actually represents the content of the document. For example, for icons the actual rect is generally smaller than the icon itself.
 * @discussion Return an image the panel will crossfade with when opening or closing. You can specify the actual \"document\" content rect in the image in contentRect.
 */
/*
- (id)previewPanel:(QLPreviewPanel *)panel transitionImageForPreviewItem:(id <QLPreviewItem>)item contentRect:(NSRect *)contentRect
{
	// optional method
	<#statements_538#>
}
*/
";
	},

	// 
	// Protocol CAMediaTiming
	// 
	{
		Identifier = objc.protocols10_6.CAMediaTiming;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "CAMediaTiming implementation (MacOSX 10.6)";
		CompletionPrefix = "CAMediaTiming";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: CAMediaTiming implementation
//

/* The begin time of the object, in relation to its parent object, if
 * applicable. Defaults to 0. */
/* The basic duration of the object. Defaults to 0. */
/* The rate of the layer. Used to scale parent time to local time, e.g.
 * if rate is 2, local time progresses twice as fast as parent time.
 * Defaults to 1. */
/* Additional offset in active local time. i.e. to convert from parent
 * time tp to active local time t: t = (tp - begin) * speed + offset.
 * One use of this is to \"pause\" a layer by setting `speed' to zero and
 * `offset' to a suitable value. Defaults to 0. */
/* The repeat count of the object. May be fractional. Defaults to 0. */
/* The repeat duration of the object. Defaults to 0. */
/* When true, the object plays backwards after playing forwards. Defaults
 * to false. */
/* Defines how the timed object behaves outside its active duration.
 * Local time may be clamped to either end of the active duration, or
 * the element may be removed from the presentation. The legal values
 * are `backwards', `forwards', `both' and `removed'. Defaults to
 * `removed'. */
";
	},

	// 
	// Protocol CIPlugInRegistration
	// 
	{
		Identifier = objc.protocols10_6.CIPlugInRegistration;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "CIPlugInRegistration implementation (MacOSX 10.6)";
		CompletionPrefix = "CIPlugInRegistration";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: CIPlugInRegistration implementation
//

/*!
    @method     load
    @abstract   the plugin gets a chance to do custom initialization (like registration check ) here
    @discussion Load gets called once by the host when the first filter from the plug-in gets instantiated. Return of true means that the plugIn successfully initialized
    @param      host    for future use only
*/
-(BOOL)load:(void*)host
{
	// required method
	<#statements_539#>
}
";
	},

	// 
	// Protocol SBApplicationDelegate
	// 
	{
		Identifier = objc.protocols10_6.SBApplicationDelegate;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "SBApplicationDelegate implementation (MacOSX 10.6)";
		CompletionPrefix = "SBApplicationDelegate";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: SBApplicationDelegate implementation
//

- (id) eventDidFail:(const AppleEvent *)event withError:(NSError *)error
{
	// required method
	<#statements_540#>
}
";
	},

	// 
	// Protocol NSPersistentStoreCoordinatorSyncing
	// 
	{
		Identifier = objc.protocols10_6.NSPersistentStoreCoordinatorSyncing;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "NSPersistentStoreCoordinatorSyncing implementation (MacOSX 10.6)";
		CompletionPrefix = "NSPersistentStoreCoordinatorSyncing";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: NSPersistentStoreCoordinatorSyncing implementation
//

/* Get the list of contexts that will be monitored during the sync.  When we pull a change from the
   session, we check that the record has not been updated in any of these contexts.  If it has, the
   change is ignored - this causes the change to be pushed in the next sync session and the sync engine
   can figure out whether there are any conflicts or not.  If no context has modified the object, the
   change will be applied to the persistent store.

   This narrows the window for collisions but does not close it completely.  Someone may change an object
   in a monitored context after the sync client has updated it.  The application must either prevent changes
   to objects modified during a sync or must be prepared to merge changes from the persistent stores with its
   contexts. */
/*
- (NSArray *)managedObjectContextsToMonitorWhenSyncingPersistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator
{
	// optional method
	<#statements_541#>
}
*/
/* Get the list of contexts that will be updated when we save changes to the persistent store.  If the
   sync handler does not implement this method, it is the caller's responsibility to reload its contexts
   at the end of a sync. */
/*
- (NSArray *)managedObjectContextsToReloadAfterSyncingPersistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator
{
	// optional method
	<#statements_542#>
}
*/
/* The following methods are called as we progress through the sync session (negotiation, pushing,
   pulling, done).  You may explicitly finish or cancel the sync session to finish syncing early. */
/*
- (BOOL)persistentStoreCoordinatorShouldStartSyncing:(NSPersistentStoreCoordinator *)coordinator
{
	// optional method
	<#statements_543#>
}
*/
/*
- (void)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator willPushChangesInSyncSession:(ISyncSession *)session
{
	// optional method
	<#statements_544#>
}
*/
/*
- (void)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator didPushChangesInSyncSession:(ISyncSession *)session
{
	// optional method
	<#statements_545#>
}
*/
/*
- (void)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator willPullChangesInSyncSession:(ISyncSession *)session
{
	// optional method
	<#statements_546#>
}
*/
/*
- (void)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator didPullChangesInSyncSession:(ISyncSession *)session
{
	// optional method
	<#statements_547#>
}
*/
/*
- (void)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator didFinishSyncSession:(ISyncSession *)session
{
	// optional method
	<#statements_548#>
}
*/
/*
- (void)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator didCancelSyncSession:(ISyncSession *)session error:(NSError *)error
{
	// optional method
	<#statements_549#>
}
*/
/* This method is called before the synchronizer pushes a record to the sync server. It can be used 
   by the delegate to modify the record on the fly.  If you return nil, no record will be pushed for
   the specified object. */
/*
- (NSDictionary *)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator willPushRecord:(NSDictionary *)record forManagedObject:(NSManagedObject *)managedObject inSyncSession:(ISyncSession *)session
{
	// optional method
	<#statements_550#>
}
*/
/*
- (BOOL)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator willDeleteRecordWithIdentifier:(NSString *)identifier inSyncSession:(ISyncSession *)session
{
	// optional method
	<#statements_551#>
}
*/
/* This method is called after the synchronizer pulls a record from the truth, and before it applies 
   it to its managed object context.  You can change the change that will be applied to the object. */
/*
- (ISyncChange *)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator willApplyChange:(ISyncChange *)change toManagedObject:(NSManagedObject *)managedObject inSyncSession:(ISyncSession *)session
{
	// optional method
	<#statements_552#>
}
*/
/* This method is called after applying a change to an object. */
/*
- (void)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator didApplyChange:(ISyncChange *)change toManagedObject:(NSManagedObject *)managedObject inSyncSession:(ISyncSession *)session
{
	// optional method
	<#statements_553#>
}
*/
/* This method is called after saving changes to the persistent stores.  Typically, this happens at the end
   of a sync but may occur multiple times during a sync.  (Essentially, whenever clientCommittedAcceptedChanges
   is called on the sync session.) */
/*
- (void)persistentStoreCoordinator:(NSPersistentStoreCoordinator *)coordinator didCommitChanges:(NSDictionary *)changes inSyncSession:(ISyncSession *)session
{
	// optional method
	<#statements_554#>
}
*/
";
	},

	// 
	// Protocol ISyncSessionDriverDataSource
	// 
	{
		Identifier = objc.protocols10_6.ISyncSessionDriverDataSource;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "ISyncSessionDriverDataSource implementation (MacOSX 10.6)";
		CompletionPrefix = "ISyncSessionDriverDataSource";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: ISyncSessionDriverDataSource implementation
//

/* Returns a unique client identifier to represent the client to the sync engine.
   This method is invoked when creating a sync client before beginning a sync session.
   Each client is identified by an id.  There are no restrictions on the content or length of an
   id, but it must be unique across all clients.  This is specified when the client is registered
   and can never be changed afterwards. */
- (NSString *)clientIdentifier
{
	// required method
	<#statements_555#>
}
/* Returns a NSURL to the client's description property list.
   See ISyncManager.h for documentation regarding the layout of this plist. */
- (NSURL *)clientDescriptionURL
{
	// required method
	<#statements_556#>
}
/* Returns a NSArray of NSURLs, each of which is a Schema Bundle
   See ISyncManager.h for documentation regarding the layout of schema bundles. */
- (NSArray * /* NSURL */)schemaBundleURLs;
/* Method called during the negotiate phase of an ISyncSession */
/* Returns the sync type the client wants for any entity. */
- (ISyncSessionDriverMode)preferredSyncModeForEntityName:(NSString *)entity
{
	// required method
	<#statements_557#>
}
/* Method called during the push phase of an ISyncSession */
/* Called with an entity to be slow synced. This returns a dictionary mapping one or more
   records (value) to their record identifiers (key). The records should be dictionaries
   suitable to be passed in to the sync server.
   To help with memory performance, the data source may choose to only return some records 
   during any given invocation of this method.  In that case, the data source should set
   *moreComing to YES.  The driver will repeatedly call this method on the data source with the
   same entity name, until the data source does not set *moreComing to YES.
   If the data source has no records to return, it should return an empty NSDictionary.
   If an error occurs in the data source, it should return nil, and set *outError to an NSError.
   If nil is returned, the sync session will be cancelled, the sync method will return NO, and
   calls to lastError will return *outError. */
- (NSDictionary *)recordsForEntityName:(NSString *)entity moreComing:(BOOL *)moreComing error:(NSError **)outError
{
	// required method
	<#statements_558#>
}
/* Methods called during the pull phase of an ISyncSession */
/* Apply the specified ISyncChange.
   If the change is of type ISyncChangeTypeAdd or ISyncChangeTypeModify, and the change was accepted,
   the client can specify a local id by setting *outRecordIdentifier.  If the client formats the incoming record,
   it should set *outRecord to the new record.  If the client does not format the incoming record, it
   should not set *outRecord.
   outRecordIdentifier and outRecord will never be nil for ISyncChangeTypeAdd and ISyncChangeTypeModify
   If *outRecordIdentifier is not set, and the change is of type ISyncChangeTypeAdd, the record's global id will be used.
   If *outRecordIdentifier is not set, and the change is of type ISyncChangeTypeModify, the record's current local id will be used.
   If the change is of type ISyncChangeTypeDelete, *outRecordIdentifier and *outRecord are ignored.
   If an error occurs in the data source, it should return ISyncSessionDriverChangeError,
   and set *outError to an NSError.
   If ISyncSessionDriverChangeError is returned, the sync session will be cancelled, the sync method will return NO, and
   calls to lastError will return *outError. */
- (ISyncSessionDriverChangeResult)applyChange:(ISyncChange *)change forEntityName:(NSString *)entityName remappedRecordIdentifier:(NSString **)outRecordIdentifier formattedRecord:(NSDictionary **)outRecord error:(NSError **)outError
{
	// required method
	<#statements_559#>
}
/* Called when the data source should remove all its records for an entity
   Clients should return YES if the resulting deletes were accepted.
   If an error occurs in the data source, it should return NO, and set *outError to an NSError.
   If NO is returned, the sync session will be cancelled, the sync method will return NO, and
   calls to lastError will return *outError. */
- (BOOL)deleteAllRecordsForEntityName:(NSString *)entityName error:(NSError **)outError
{
	// required method
	<#statements_560#>
}
";
	},

	// 
	// Protocol DOMEventListener
	// 
	{
		Identifier = objc.protocols10_6.DOMEventListener;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "DOMEventListener implementation (MacOSX 10.6)";
		CompletionPrefix = "DOMEventListener";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: DOMEventListener implementation
//

- (void)handleEvent:(DOMEvent *)evt
{
	// required method
	<#statements_561#>
}
";
	},

	// 
	// Protocol DOMEventTarget
	// 
	{
		Identifier = objc.protocols10_6.DOMEventTarget;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "DOMEventTarget implementation (MacOSX 10.6)";
		CompletionPrefix = "DOMEventTarget";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: DOMEventTarget implementation
//

- (void)addEventListener:(NSString *)type listener:(id <DOMEventListener>)listener useCapture:(BOOL)useCapture AVAILABLE_WEBKIT_VERSION_3_0_AND_LATER
{
	// required method
	<#statements_562#>
}
- (void)removeEventListener:(NSString *)type listener:(id <DOMEventListener>)listener useCapture:(BOOL)useCapture AVAILABLE_WEBKIT_VERSION_3_0_AND_LATER
{
	// required method
	<#statements_563#>
}
- (BOOL)dispatchEvent:(DOMEvent *)event
{
	// required method
	<#statements_564#>
}
- (void)addEventListener:(NSString *)type :(id <DOMEventListener>)listener :(BOOL)useCapture AVAILABLE_WEBKIT_VERSION_1_3_AND_LATER_BUT_DEPRECATED_IN_WEBKIT_VERSION_3_0
{
	// required method
	<#statements_565#>
}
- (void)removeEventListener:(NSString *)type :(id <DOMEventListener>)listener :(BOOL)useCapture AVAILABLE_WEBKIT_VERSION_1_3_AND_LATER_BUT_DEPRECATED_IN_WEBKIT_VERSION_3_0
{
	// required method
	<#statements_566#>
}
";
	},

	// 
	// Protocol DOMNodeFilter
	// 
	{
		Identifier = objc.protocols10_6.DOMNodeFilter;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "DOMNodeFilter implementation (MacOSX 10.6)";
		CompletionPrefix = "DOMNodeFilter";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: DOMNodeFilter implementation
//

- (short)acceptNode:(DOMNode *)n
{
	// required method
	<#statements_567#>
}
";
	},

	// 
	// Protocol DOMXPathNSResolver
	// 
	{
		Identifier = objc.protocols10_6.DOMXPathNSResolver;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "DOMXPathNSResolver implementation (MacOSX 10.6)";
		CompletionPrefix = "DOMXPathNSResolver";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: DOMXPathNSResolver implementation
//

- (NSString *)lookupNamespaceURI:(NSString *)prefix
{
	// required method
	<#statements_568#>
}
";
	},

	// 
	// Protocol WebDocumentView
	// 
	{
		Identifier = objc.protocols10_6.WebDocumentView;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "WebDocumentView implementation (MacOSX 10.6)";
		CompletionPrefix = "WebDocumentView";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: WebDocumentView implementation
//

/*!
    @method setDataSource:
    @abstract Called when the corresponding data source has been created.
    @param dataSource The corresponding data source.
*/
- (void)setDataSource:(WebDataSource *)dataSource
{
	// required method
	<#statements_569#>
}
/*!
    @method dataSourceUpdated:
    @abstract Called when the corresponding data source has received data.
    @param dataSource The corresponding data source.
*/
- (void)dataSourceUpdated:(WebDataSource *)dataSource
{
	// required method
	<#statements_570#>
}
/*!
    @method setNeedsLayout:
    @discussion Called when WebKit has determined that the document view needs to layout.
    This method should simply set a flag and call layout from drawRect if the flag is YES.
    @param flag YES to cause a layout, no to not cause a layout.
*/
- (void)setNeedsLayout:(BOOL)flag
{
	// required method
	<#statements_571#>
}
/*!
    @method layout
    @discussion Called when the document view must immediately layout. For simple views,
    setting the frame is a sufficient implementation of this method.
*/
- (void)layout
{
	// required method
	<#statements_572#>
}
/*!
    @method viewWillMoveToHostWindow:
    @param hostWindow The host window for the document view.
    @abstract Called before the host window is set on the parent web view.
*/
- (void)viewWillMoveToHostWindow:(NSWindow *)hostWindow
{
	// required method
	<#statements_573#>
}
/*!
    @method viewDidMoveToHostWindow
    @abstract Called after the host window is set on the parent web view.
*/
- (void)viewDidMoveToHostWindow
{
	// required method
	<#statements_574#>
}
";
	},

	// 
	// Protocol WebDocumentSearching
	// 
	{
		Identifier = objc.protocols10_6.WebDocumentSearching;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "WebDocumentSearching implementation (MacOSX 10.6)";
		CompletionPrefix = "WebDocumentSearching";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: WebDocumentSearching implementation
//

/*!
    @method searchFor:direction:caseSensitive:wrap:
    @abstract Searches a document view for a string and highlights the string if it is found.
    @param string The string to search for.
    @param forward YES to search forward, NO to seach backwards.
    @param caseFlag YES to for case-sensitive search, NO for case-insensitive search.
    @param wrapFlag YES to wrap around, NO to avoid wrapping.
    @result YES if found, NO if not found.
*/
- (BOOL)searchFor:(NSString *)string direction:(BOOL)forward caseSensitive:(BOOL)caseFlag wrap:(BOOL)wrapFlag
{
	// required method
	<#statements_575#>
}
";
	},

	// 
	// Protocol WebDocumentText
	// 
	{
		Identifier = objc.protocols10_6.WebDocumentText;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "WebDocumentText implementation (MacOSX 10.6)";
		CompletionPrefix = "WebDocumentText";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: WebDocumentText implementation
//

/*!
    @method supportsTextEncoding
    @result YES if the document view support text encoding, NO if it doesn't.
*/
- (BOOL)supportsTextEncoding
{
	// required method
	<#statements_576#>
}
/*!
    @method string
    @result String that represents the entire document.
*/
- (NSString *)string
{
	// required method
	<#statements_577#>
}
/*!
    @method attributedString
    @result Attributed string that represents the entire document.
*/
- (NSAttributedString *)attributedString
{
	// required method
	<#statements_578#>
}
/*!
    @method selectedString
    @result String that represents the current selection.
*/
- (NSString *)selectedString
{
	// required method
	<#statements_579#>
}
/*!
    @method selectedAttributedString
    @result Attributed string that represents the current selection.
*/
- (NSAttributedString *)selectedAttributedString
{
	// required method
	<#statements_580#>
}
/*!
    @method selectAll
    @abstract Selects all the text in the document.
*/
- (void)selectAll
{
	// required method
	<#statements_581#>
}
/*!
    @method deselectText
    @abstract Causes a text selection to lose its selection.
*/
- (void)deselectAll
{
	// required method
	<#statements_582#>
}
";
	},

	// 
	// Protocol WebDocumentRepresentation
	// 
	{
		Identifier = objc.protocols10_6.WebDocumentRepresentation;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "WebDocumentRepresentation implementation (MacOSX 10.6)";
		CompletionPrefix = "WebDocumentRepresentation";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: WebDocumentRepresentation implementation
//

/*!
    @method setDataSource:
    @abstract Called soon after the document representation is created.
    @param dataSource The data source that is set.
*/
- (void)setDataSource:(WebDataSource *)dataSource
{
	// required method
	<#statements_583#>
}
/*!
    @method receivedData:withDataSource:
    @abstract Called when the data source has received data.
    @param data The data that the data source has received.
    @param dataSource The data source that has received data.
*/
- (void)receivedData:(NSData *)data withDataSource:(WebDataSource *)dataSource
{
	// required method
	<#statements_584#>
}
/*!
    @method receivedError:withDataSource:
    @abstract Called when the data source has received an error.
    @param error The error that the data source has received.
    @param dataSource The data source that has received the error.
*/
- (void)receivedError:(NSError *)error withDataSource:(WebDataSource *)dataSource
{
	// required method
	<#statements_585#>
}
/*!
    @method finishedLoadingWithDataSource:
    @abstract Called when the data source has finished loading.
    @param dataSource The datasource that has finished loading.
*/
- (void)finishedLoadingWithDataSource:(WebDataSource *)dataSource
{
	// required method
	<#statements_586#>
}
/*!
    @method canProvideDocumentSource
    @result Returns true if the representation can provide document source.
*/
- (BOOL)canProvideDocumentSource
{
	// required method
	<#statements_587#>
}
/*!
    @method documentSource
    @result Returns the textual source representation of the document.  For HTML documents
    this is the original HTML source.
*/
- (NSString *)documentSource
{
	// required method
	<#statements_588#>
}
/*!
    @method title
    @result Return the title for the document.
*/
- (NSString *)title
{
	// required method
	<#statements_589#>
}
";
	},

	// 
	// Protocol WebPlugInViewFactory
	// 
	{
		Identifier = objc.protocols10_6.WebPlugInViewFactory;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "WebPlugInViewFactory implementation (MacOSX 10.6)";
		CompletionPrefix = "WebPlugInViewFactory";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: WebPlugInViewFactory implementation
//

/*!
    @method plugInViewWithArguments: 
    @param arguments The arguments dictionary with the mentioned keys and objects. This method is required to implement.
    @result Returns an NSView object that conforms to the WebPlugIn informal protocol.
*/
+ (NSView *)plugInViewWithArguments:(NSDictionary *)arguments
{
	// required method
	<#statements_590#>
}
";
	},

	// 
	// Protocol WebPolicyDecisionListener
	// 
	{
		Identifier = objc.protocols10_6.WebPolicyDecisionListener;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "WebPolicyDecisionListener implementation (MacOSX 10.6)";
		CompletionPrefix = "WebPolicyDecisionListener";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: WebPolicyDecisionListener implementation
//

/*!
    @method use
    @abstract Use the resource
    @discussion If there remain more policy decisions to be made, then
    the next policy delegate method gets to decide. This will be
    either the next navigation policy delegate if there is a redirect,
    or the content policy delegate. If there are no more policy
    decisions to be made, the resource will be displayed inline if
    possible. If there is no view available to display the resource
    inline, then unableToImplementPolicyWithError:frame: will be
    called with an appropriate error. 

    <p>If a new window is going to be created for this navigation as a
    result of frame targetting, then it will be created once you call
    this method.
*/
- (void)use
{
	// required method
	<#statements_591#>
}
/*!
    @method download
    @abstract Download the resource instead of displaying it.
    @discussion This method is more than just a convenience because it
    allows an in-progress navigation to be converted to a download
    based on content type, without having to stop and restart the
    load.
*/
- (void)download
{
	// required method
	<#statements_592#>
}
/*!
    @method ignore
    @abstract Do nothing (but the client may choose to handle the request itself)
    @discussion A policy of ignore prevents WebKit from doing anything
    further with the load, however, the client is still free to handle
    the request in some other way, such as opening a new window,
    opening a new window behind the current one, opening the URL in an
    external app, revealing the location in Finder if a file URL, etc.
*/
- (void)ignore
{
	// required method
	<#statements_593#>
}
";
	},

	// 
	// Protocol WebOpenPanelResultListener
	// 
	{
		Identifier = objc.protocols10_6.WebOpenPanelResultListener;
		BasedOn = objc.protocols10_6;
		IsMenuItem = YES;
		Name = "WebOpenPanelResultListener implementation (MacOSX 10.6)";
		CompletionPrefix = "WebOpenPanelResultListener";
		OnlyAtBOL = YES;
		TextString = "
//
// MARK: WebOpenPanelResultListener implementation
//

/*!
    @method chooseFilename:
    @abstract Call this method to return a filename from the file open panel.
    @param fileName
*/
- (void)chooseFilename:(NSString *)fileName
{
	// required method
	<#statements_594#>
}
/*!
    @method chooseFilenames:
    @abstract Call this method to return an array of filenames from the file open panel.
    @param fileNames
*/
- (void)chooseFilenames:(NSArray *)fileNames WEBKIT_OBJC_METHOD_ANNOTATION(AVAILABLE_IN_WEBKIT_VERSION_4_0)
{
	// required method
	<#statements_595#>
}
/*!
    @method cancel
    @abstract Call this method to indicate that the file open panel was cancelled.
*/
- (void)cancel
{
	// required method
	<#statements_596#>
}
";
	},
)
